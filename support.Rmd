--- 
title: "Les données spatiales avec R"
author: "Maël THEULIERE"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [packages.bib]
biblio-style: apalike
link-citations: yes
description: "Support de cours du module du même nom du master Mégadonnées et Analyse sociale du CNAM de Loire-Atlantique"
---

# Introduction {-}

![](pic/odonate.jpg)

<font size="2"> 
*Crédit photographique Pascal Boulin*
</font> 


## Le parcours de formation

Ce dispositif de formation vise à faire monter en compétence les agents du MTES (Ministère de la transition écologique et solidaire) et du MCT (Ministère de la cohésion des territoires) dans le domaine de la science de la donnée avec le logiciel R. Il est conçu pour être déployé à l'échelle nationale par le réseau des CVRH (Centre de Valorisation des Ressources Humaines).

Le parcours proposé est structuré en modules de 2 jours chacun. Les deux premiers (ou un niveau équivalent) sont des pré-requis pour suivre les suivants qui sont proposés "à la carte" :

1. Socle : Premier programme en R
2. Socle : Préparation des données
3. Statistiques descriptives
4. Analyses multivariées
5. Datavisualisation : Produire des graphiques, des cartes et des tableaux
6. Documents reproductibles avec RMarkdown (2^ème^ trimestre 2020)
7. Analyse spatiale 
... et en perspective : applis interactives avec Shiny, big data, etc.


La mise à disposition des supports de formation se fait désormais par la [page d'accueil du parcours de formation](https://mtes-mct.github.io/parcours-r/). Ces supports sont en [licence ouverte](https://www.etalab.gouv.fr/wp-content/uploads/2017/04/ETALAB-Licence-Ouverte-v2.0.pdf).


Si vous souhaitez accéder aux sources ou aux données mobilisées pendant les formations, il faut directement les télécharger depuis le [Github du ministère](https://github.com/MTES-MCT?q=parcours-r).

Pour vous tenir au courant de l'offre de formation proposée par le réseau des CVRH, [consultez la plateforme OUPS](http://oups-cmvrh.e2.rie.gouv.fr/) (un accès intranet MTES-MCT est nécessaire). Vous pouvez vous y abonner pour recevoir les annonces de formation qui vous intéressent.

Il existe une liste pour échanger de l'information, discuter autour de R ou encore faire part de difficultés pour trouver ensemble les solutions. Pour s'insrire, envoyer un message vide avec le titre "subscribe labo.communaute-r" à l'adresse sympa@developpement-durable.gouv.fr.

## Objectifs de ce module

L’objectif de ce module est de présenter les éléments de manipulation des données spatiales à partir de R. Nous verrons ainsi :

- Ce que sont les données spatiales
- Comment lire des données spatiales ?
- Comment manipuler les données spatiales ?
- Comment visualiser les données spatiales ?



```{r setup, eval=T,echo=F,message=F,warning=F}
knitr::opts_chunk$set(cache=T,echo=T,comment="",message=F,warning = F)
#Chargement des packages et des données.
library(knitr)
library(kableExtra)
library(ggplot2)
library(tidyverse)
library(stringr)
library(purrr)
library(sf)
library(tmap)
library(viridis)
library(scales)
library(tmaptools)
library(leaflet)
library(cowplot)
library(glue)
library(htmlwidgets)
library(rmapshaper)
library(patchwork)
library(cartogram)
library(ggspatial)
library(lwgeom)
library(mapview)

theme_set(theme_gray())
tmap_mode("plot")
```

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr','kableExtra', 'rmarkdown','sf','ggplot2','tmap'
), 'packages.bib')
```

<!--chapter:end:index.Rmd-->

# Bien commencer


## Créer un projet sous Rstudio pour vous permettre de recenser vos travaux.

Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ?

- Cela permet la portabilité : le répertoire de travail par défaut d'un projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de l'arborescence de votre machine.

> **Fini les `setwd("chemin/qui/marche/uniquement/sur/mon/poste")` !** 


- Toujours sur la portabilité, un projet peut être utilisé avec un package comme `packrat` ou `renv` qui vont vous permettre d'internaliser au sein du projet l'ensemble des packages dont vous aurez besoin dans la version avec laquelle vous l'avez utilisé. Cela permet donc à votre collègue à qui vous passez votre projet de ne pas avoir à les installer dans la même version, et si vous mettez à jour votre environnement R, votre projet restera toujours avec les versions des packages avec lesquelles vous l'avez fait tourner à l'époque. Cela évite d'avoir à subir les effets d'une mise à jour d'un package qui casserait votre code.

`Packrat` est intégré à Rstudio. Pour activer `packrat` sur un projet, aller dans `Tools/Project Options->Packrat`

[En savoir plus sur Packrat](https://www.rstudio.com/resources/webinars/managing-package-dependencies-in-r-with-packrat/)

![](pic/creerprojet4.png){#id .class width=500}

`renv` est plus récent que `Packrat`, il n'est pas encore intégré à Rstudio mais apporte des améliorations subsentielles par rapport à son prédécesseur. 
[En savoir plus sur renv](https://rstudio.github.io/renv/)

- Cela permet de se forcer à travailler en mode projet : on intègre à un seul endroit tous ce qui est lié à ce projet : données brutes, données retravaillées, scripts, illustrations, documentations, publications... et donc y compris packages avec `packrat` ou `renv`.

- On peut travailler sur plusieurs projets en même temps, Rstudio ouvre alors autant de sessions que de projets.

- Les projets Rstudio intègrent une interface avec les outils de gestion de version `git` et `svn.` Cela veut dire que vous pouvez versionniser votre projet et l'héberger simplement comme répertoire sur des plateformes de gestion de code telle que `github` ou `gitlab.`

**Pour créer un projet : **

- Cliquez sur *Project* en haut à droite puis *New Project*.
![](pic/creerprojet1.png){#id .class width=500}


- Cliquez sur *New Directory*.
![](pic/creerprojet2.png){#id .class width=500}

## Désactiver les options de sauvegarde automatique de Rstudio

Votre code doit être reproductible depuis vos données en entrée vers votre résultat. Pour cela, il est fortement déconseillé de sauvegarder quoique ce soit dans le fichier `.RData` de sauvegarde par défaut. 

Pour cela, aller dans *Tools->Global Options...* et ensuite conformez vous à ceci

![](pic/RData.png)

## Intégrer vos données

Une bonne pratique est de créer un sous répertoire `/extdata` pour stocker les données sur lesquelles vous aurez à travailler et un dossier `/data` pour stocker les données après préparation. 

Vous pouvez le faire de l'explorateur de fichier de votre système d'exploitation ou directement à partir de l'explorateur de fichier de RStudio.
![](pic/creerprojet3.png){#id .class width=500}

Si par la suite vous souhaitez avoir des exemples de bonnes pratiques sur comment structurer vos données, vous pouvez vous référer au [chapitre data](http://r-pkgs.had.co.nz/data.html) du livre d'Hadley Wickham sur la construction de package R (tout package R étant aussi un projet !)

## Créer votre arborescence de projet

- Créer un répertoire `/src` où vous mettrez vos scripts R.

- Créer un répertoire `/figures` où vous mettrez vos illustrations issues de R.

## Activer les packages nécessaires

Commencer par rajouter un script dans le répertoire `/src` à votre projet qui commencera par : 

- activer l'ensemble des packages nécessaires

- charger les données dont vous aurez besoin.

## Bien structurer ses projets data

Plusieurs documents peuvent vous inspirer sur la structuration de vos projets data par la suite.

En voici quelques uns : 

- https://github.com/pavopax/new-project-template
- https://nicercode.github.io/blog/2013-04-05-projects/
- https://www.inwt-statistics.com/read-blog/a-meaningful-file-structure-for-r-projects.html
- http://projecttemplate.net/architecture.html

A partir du moment où quelques grands principes sont respectés (un répertoire pour les données brutes en lecture seule par exemple), le reste est surtout une question d'attirance plus forte pour l'une ou l'autre solution. L'important est de vous tenir ensuite à garder toujours la même structure dans vos projets afin de vous y retrouver plus simplement.

<!--chapter:end:01-get-started.Rmd-->

# (PART) Introduction aux données spatiales {-}

# La modélisation des données spatiales

Dans ce chapitre,nous allons développer une brève introduction à la modélisation des données géographiques.

## Les données vecteur

Les données vecteur sont une modélisation du monde utilisant des points, des lignes et des polygones.
Les données "vecteur" sont en général plus utilisées en sciences sociales, les territoires créés par l'homme ayant la plupart du temps des frontières discrètes.

Derrière les données vecteur, se trouvent des points. Les points peuvent représenter des caractéristiques autonomes (comme l'emplacement de l'établissement d'une entreprise), ou peuvent être reliés entre eux pour former des géométries plus complexes telles que des lignes (comme des cours d'eau) et des polygones (les frontières d'un pays). 

Ces points sont localisés à travers un système de référence de coordonnées (CRS). La plupart des géométries ponctuelles ne contiennent que deux dimensions (les CRS à trois dimensions contiennent une valeur supplémentaire z pour la hauteur du point en référence au niveau de la mer).


## Les données raster

Les données raster modélisent la surface du globe à l'aide de celulles de taille identique.
Les données "raster" sont en générale plus utilisées dans les science environnementales, du fait de la fiabilité des données de télédétections disponibles.

## La structuration des données géographiques avec R

### sf pour les données vecteur

Le packages `sf` permet de gérer les données vecteur.

Avant `sf` existait le package `sp` que vous pourrez rencontrer suivant les packages plus spécifiques que vous utiliserez ou en cherchant de l'aide.

Les avantages de `sf` sont multiples : 

- **Standardisation** : sf utilise le modèle de données simple feature^[https://en.wikipedia.org/wiki/Simple_Features] qui est un standard largement utilisé dans le domaine de la géomatique.

- **Simplification** du modèle de données. Les données spatiales sont un *dataframe* avec une variable spécifique renseignant la géométrie en créant un type ad hoc en plus des types standard (numériques, entiers, booléens, caractères, facteur...). Ce dataframe aura une classe spécifique qui lui sera associée (classe `sf`).

- La syntaxe des fonctions est **unifiée** et **simplifiée** selon le manifeste du tidyverse^[https://tidyverse.tidyverse.org/articles/manifesto.html]. 

- **Intégration**. Les verbes du tidyverse sont compatibles avec les données spatiales de classe `sf` et vont parfois agir avec des propriétés spécifiques sur les données géométriques. On peut également utiliser le *pipe* dans le processus de travail.

- **Perfomance** : meilleure performance dans la lecture et l'écrite des données. Voir un benchmark sur la [page du package sf](https://r-spatial.github.io/sf/articles/sf1.html#benchmarks)

### raster et stars pour les données raster

Les packages `raster` et `stars` permettent de gérer les données raster. 

`raster` est aussi un package historique amené à être supplanté par `stars`.

`stars` est d'une part plus vaste que `raster`, car il vise à gérer les données spatio-temporelle plus largement.

`stars` est intégré à `sf` et au `tidyverse`

On se limitera pour la suite du cours aux données vecteur et donc à `sf`.

<!--chapter:end:02-modelisation.Rmd-->

# Les Systèmes de Coordonnées de Référence

Les données spatiales vises à modéliser la terre. 
La terre est un objet dont la mesure a une longue histoire, qu'on a pensé plate, cylindrique, ronde,  ellipsoïde. Maintenant, on sait que la terre a cette forme là : 

<iframe src="https://player.vimeo.com/video/213210796" width="640" height="640" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
<p><a href="https://vimeo.com/213210796">THE REAL SHAPE OF PLANET EARTH - 3D Animation HD</a> from <a href="https://vimeo.com/elearnpunjab">eLearn.Punjab</a> on <a href="https://vimeo.com">Vimeo</a>.</p>

Les systèmes de coordonnées de référence vont permettre de se repérer sur la surface de la terre.

## Le système géodésique ou datum

Pour modéliser la surface terrestre, on va définir un *géoïde*, qui est la surface théorique de la pesanteur.

Ce *géoïde* est proche d'un ellipsoïde, c'est à dire une surface obtenue en faisant tourner une ellipse sur son axe. La terre est en effet compressée :  le rayon à l'équateur est 11,5 km plus long que le rayon polaire (Maling 1992).

On va donc pouvoir approximer ce géoïde par un ellipsoïde.

![](pic/datum.png)

Un point quelconque est repéré par rapport à l’ellipsoïde en utilisant un système de coordonnées sphériques : longitude, latitude, altitude.

Le *datum* ou *système géodésique* va correspondre aux paramètre de forme de l'ellipsoïde et de positionnement sur celle ci.

On va distinguer deux types de datum : les datum *locaux* et les datum *globaux*.

Historiquement n'existait que des datum locaux, c'est à dire qui définissait une ellipse optimale pour correspondre à une partie déterminée de la surface de la terre. Cette contrainte était liée à la façon de définir le géoïde : avant les techniques spatiales, on utilisait des mesures de triangulation à partir d'un point défini par mesure astronomique.

![](http://www.ngi.be/images/2/1/lokalgeodatf.gif)

Depuis l'avènement des techniques spatiales, on est capable de définir un *datum global* grâce aux mesures satellitaires. Le système mondial de référence est aujourd'hui le WGS 84, associé au GPS.

Il y a donc aujourd'hui beaucoup de *datum*, un pour la plupart des pays, qui maximise la modélisation de l'ellipsoïde sur leur territoire, et des datums globaux.

## Les coordonnées

Pour se repérer sur terre, on va utiliser un système géodésique sur lequel on va se positionner avec des coordonnées. 

On distingue deux types de coordonnées :

### Coordonnées géographiques

Les systèmes de coordonnées géographiques identifient tout lieux sur la surface de la terre en utilisant deux paramètres, la longitude et la lattitude : 

- La Longitude est la localisation sur la direction Est-Ouest. Elle est définie par l'angle par rapport à un méridien.

- La Latitude définie la localisation sur la direction Nord-Sud. Elle est définie par l'angle avec l'équateur. 

<iframe width="560" height="315" src="https://www.youtube.com/embed/eSTJV40Lzro" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


Dans un système de coordonnées géographiques, les lieux sont donc identifiés par des *angles* et non des *mètres*.


### Coordonnées en projection

Les systèmes de coordonnées projetés se basent sur une modélisation de la terre plane (donc projetée sur un plan) et un système de coordonnés cartésien pour définir un point sur ce plan à partir d'une origine, d'un axe x, d'un axe y et d'une unité de mesure (comme le mètre).

Tous les systèmes de coordonnées projetés se basent sur un système de coordonnées géographiques et sur une projection spatiale des données de l'ellipse en 3D sur un plan.

Cet exercice ne peut se faire sans distorsion. Les propriétés de la surface de la terre comme l'aire, la direction, la distance, la forme ne peuvent être toutes conservées.

En général un système de coordonnées projetés ne permet de préserver qu'une ou deux de ces propriétés. On classifie d'ailleurs ces projections selon les propriétés conservées  : 

- conformes (conservent les angles)
- équivalentes (conservent les surfaces) 
- aphylactique (peut être équidistante, c'est-à-dire conserver les distances sur les méridiens)

On distingue également les projection en fonction de leur mode de projection. Il y a trois principaux groupes de projections : 

- Conique : la terre est projetée sur un cone reposant sur une ou deux tangentes. Les distorsions sont faibles sur la ligne de tangente et augmentent ensuite avec la distance à celle-ci. C'est ainsi le type de projection le mieux adapté pour des cartes réalisées sur des latitudes médianes.

- Cylindrique : ces projections projettent la surface de la terre sur un cylindre. Souvent utilisées pour cartographier la terre entière.

- Plane : projection du globe sur une surface plane tangeante en un point ou sur une ligne. Souvent utilisée pour les régions polaires.

### Exemple de projections

#### Equal Earth

Le but de la projection [Equal-Earth](http://equal-earth.com) est de représenter la Terre avec toutes ses régions à part égale.

Equal Earth est une projection pseudo-cylindrique ressemblant à celle de Robinson qui évoque comme elle la rotondité de la Terre. Mais à la différence de cette dernière, elle préserve les surfaces.
 
- http://cartonumerique.blogspot.com/2018/11/la-projection-equal-earth.html

## Code EPSG

L'EPSG (European Petroleum Survey Group), un groupe créé en 1985, a défini une liste des systèmes de coordonnées géoréférencées et leur a associé des codes pour les identifier. Le groupe est devenu en 2005 le "Comité de topographie et de positionnement" de l'Association internationale des producteurs de pétrole et de gaz (OGP). La liste peut être trouvée sur [ce site](http://www.epsg.org/).

Un système géodésique peut recevoir plusieurs codes EPSG selon son utilisation : 2D ou 3D par exemple.

<!--chapter:end:03-crs.Rmd-->

# (PART) Lire et écrire des données spatiales {-}

# Lire et écrire des données spatiales avec R

Dans ce chapitre, nous allons utiliser les packages suivants : 

```{r}
library(sf)
library(DT)
library(tidyverse)
library(RPostgres)
library(spData)
```

Le package `sf` s'appuie sur `GDAL` (Geospatial Data Abstraction Library) pour lire et écrire les données spatiales.

`GDAL` est une librairie permettant de lire et d'écrire des données vecteur et raster de n'importe quel format de fichier ou base de données.

Les fonctions de lecture et d'écriture de `sf` s'appellent `st_read()` et `st_write()`.

Pour lire des données spatiales,s `st_read()` a besoin :

- d'une source de donnée : un fichier, un répertoire, une base de données ;
- d'un layer: une table de données spatiale spécifique du fichier, répertoire, ou de la base de données ;

On peut avoir besoin de rajouter des options spécifiques au format de la source. Par exemple, sur des données en `csv`, il faut pouvoir spécifier la composante spatiale des données.

## Lire des fichiers plats

`st_read()` permet de lire des données spatiales disponibles en fichier plat.

Le format de fichier plat le plus populaire en géomatique est `ESRI Shapefile`. Ce format, en plus de ne pas être un format ouvert, a des limites bien documentées^[voir http://switchfromshapefile.org/]. 

Avec l'avènement du web, le format `GeoJSON` se développe beaucoup, bien qu'il soit aussi limité.

Le format considéré comme le plus prometeur est le format `OGC GeoPackage` promu par l'Open Geospatial Consortium^[https://www.geopackage.org/].

Mais la liste des formats lisibles par `sf` est bien plus vaste.

Pour l'obtenir, on peut utiliser `st_drivers()`

```{r}
DT::datatable(st_drivers() %>% arrange(name))
```

Exemple de lecture d'une donnée au format `GeoPackage`: les données sur la Leucémie à New York disponibles dans le package `spData`^[Issues de Waller and Gotway (2004) Applied Spatial Statistics for Public Health Data.].

```{r,eval=F}
geo_fichier <- system.file("shapes/NY8_bna_utm18.gpkg", package = "spData")
NY_leukemia <- st_read(dsn = geo_fichier)
```

## Ecrire des fichiers plats

Ecrire des fichiers plats va se faire avec la fonction `st_write()`.

```{r,message = T,eval=F}
st_write(obj = NY_leukemia, dsn = "data/NY_leukemia.gpkg")
```

Notez que si vous cherchez à exporter une nouvelle fois ce fichier, vous aurez un message d'erreur.

Pour pouvoir écraser ce fichier, vous avez deux options : 

- Utiliser le paramètre `layer_option` qui vous permet d'inclure des options propres au driver utilisé.

```{r,eval=F}
st_write(
  obj = NY_leukemia,
  dsn = "data/NY_leukemia.gpkg",
  append=FALSE
)
```


- Utiliser le paramètre `delete_layer = T` de `st_write()` qui vous permet d'écraser les layer avant sauvegarde (paramètre qui ne dépend pas du driver utilisé).

```{r,eval=F}
st_write(
  obj = NY_leukemia,
  dsn = "data/NY_leukemia.gpkg",
  delete_layer = T
)
```

## Lire/écrire des données spatiales sur PostGIS

`PostGIS`, c'est l'extension géomatique de `PostgreSQL` permettant de stocker des données géo sur un serveur de données et de les manipuler.

R va vous permettre de vous connecter simplement à une base PostGIS, pour cela vous aurez besoin du package `DBI` (package permettant de s'interfacer à des bases de données) et du package `RPostgres` (interface à PostgreSQL)

Rstudio a développé tout un site sur les interactions entre les bases de données et R, vous pouvez le trouver à l'adresse suivante : [db.rstudio.com](https://db.rstudio.com/).

Rstudio possède même depuis la version 1.1 un onglet de connexion vous permetttant de visualiser vos connexions aux bases.

Pour se connecter à une base, on va définir un driver (à quelle type de base on veut se connecter) et un connecteur (les informations de connexion).

```{r,eval = F}
drv <- dbDriver("Postgres")
con <- dbConnect(drv,
  dbname = "nom_de_ma_db",
  host = "adresse_ip_du_serveur",
  port = numero_du_port,
  user = "nom_utilisateur",
  password = "mot_de_passe_super_secret"
)
```


Pour lire des données sur le serveur, on va utiliser encore la fonction `st_read()` en lui définissant 2 paramètres : le connecteur et la requête que l'on veut réaliser.

```{r,eval = F}
ma_table <- st_read(con, query = "SELECT * FROM le_schema.ma_table")
```

L'avantage ici est que vous pouvez faire travailler le serveur directement sans avoir à faire travailler votre poste de travail.

Vous pouvez très bien dans cette requête sql réaliser quelques filtres, sélections et aggrégations. Celles-ci seront alors réalisées par le serveur posgreSQL et non R qui ne récupèrera que le résultat.

Vous pouvez écrire vos données ensuite de la même façon avec `st_write()`

```{r,eval = F}
st_write(ma_table,
  dsn = con,
  layer = ID(schema = "schema", table = "ma_table")
)
```

## Convertir un dataframe

Une autre façon d'obtenir un *spatial dataframe* est de convertir un objet existant en objet sf. Par exemple, partir d'un dataframe sur lequel on va définir à la fois la ou les colonnes contenant la dimension géographique et le crs de référence. Ou encore convertir un objet de type `sp` en objet de type `sf`.

Pour cela, la fonction `st_as_sf()` permet de convertir un objet en objet `sf` en définissant la composante spatiale.

La fonction `st_set_crs()` permet de définir le crs de notre objet.

Exemple, nous allons lire les coordonnées géographiques des préfectures de région.

```{r,message = F}
prefectures <- read_csv2("data/prefecture.csv")
prefectures_geo <- st_as_sf(prefectures, coords = c("x", "y")) %>%
  st_set_crs(2154)
```

 

<!--chapter:end:04-lire-des-donnees-spatiales.Rmd-->

# (PART) Manipuler des données spatiales {-}

# Les opérations sur données attributaires

Dans ce chapitre, nous allons utiliser les packages suivants : 

```{r}
library(sf)
library(tidyverse)
library(mapview)
```

Nous utiliserons les contours des territoires de la France métropolitaine issus de Admin Express.


```{r}
load("data/admin_express.RData")
```

Prenons la table des départements, cette table est un `spatial dataframe`.

```{r}
class(departements_geo)
```

On peut utiliser `mapview()` pour voir ce jeu de données.

```{r}
mapview(departements_geo, zcol = "NOM_DEP", legend = F)
```

Comme évoqué dans la partie 1, on peut tout à fait appliquer sur un `spatial dataframe` les verbes du `tidyverse` comme sur un `dataframe`, notamment utiliser  les verbes de `dplyr`.

Nous pouvons à partir de cette table filtrer les départements d'une certaine région.

```{r}
departements_geo %>%
  filter(INSEE_REG == 52)
```

Nous pouvons ne sélectionner que quelques variables

```{r}
departements_geo %>%
  select(INSEE_DEP) %>%
  glimpse()
```

A noter que par défaut, un `spatial dataframe` gardera toujours la géométrie.

Nous pouvons agréger nos données.

```{r}
regions <- departements_geo %>%
  group_by(INSEE_REG) %>%
  summarise(AREA = sum(AREA))

glimpse(regions)
```

On voit que `summarise` permet non seulement d'agréger nos données attributaires, mais également les géométries.

Cette opération permet donc de retrouver directement notre carte des régions métropolitaines.

```{r}
mapview(regions, zcol = "INSEE_REG", legend = F)
```

On peut enfin effectuer des jointures attributaines sur nos données en utilisant les verbes à deux dataframe de `dplyr`.

Par exemple on va pouvoir récupérer, dans la table `regions_geo` de notre `RData`, les libellées de nos régions.

```{r}
regions <- regions %>%
  left_join(regions_geo %>%
    st_drop_geometry(),
  by = c("INSEE_REG")
  )
```

Nous pouvons alors utiliser ce nouvelle attribut pour nos cartes.

```{r}
mapview(regions, zcol = "NOM_REG", legend = F)
```

```{block, type='rmdnote'}
Attention, quand vous réalisez une jointure entre deux tables de données :

X %>% ZZ_join(Y) 

La composante spatiale n'est conservée que pour la première table X.
```

<!--chapter:end:05-operation-sur-donnees-attributaires.Rmd-->

# Les opérations spatiales sur les données


Les opérations spatiales sont des opérations prenant nos données en entrée pour en sortir un résultat dépendant de leur composante spatiale (forme, localisation).

Dans ce chapitre, nous allons utiliser les packages suivants.

```{r}
library(sf)
library(tidyverse)
library(mapview)
library(ggplot2)
```

Nous utiliserons les données de la table des régions de la France métropolitaine et des établissements publics de coopération intercommunale (EPCI)^[https://fr.wikipedia.org/wiki/%C3%89tablissement_public_de_coop%C3%A9ration_intercommunale] de la France Métropolitaine


```{r}
load("data/admin_express.RData")
```

```{r}
glimpse(epci_geo)
```

```{r}
glimpse(departements_geo)
```

```{r}
glimpse(regions_geo)
```

## Filtrer

Nous souhaitons par exemple filtrer nos EPCI sur les EPCI du département de Loire-Atlantique.

```{r}
departement_44 <- departements_geo %>%
  filter(INSEE_DEP == "44")

epci_d44 <- epci_geo[departement_44, , op = st_within]

mapview(list(departement_44, epci_d44), zcol = list("NOM_DEP", "NOM_EPCI"), legend = F)
```

L'opération de filtre sur les données spatiales fonctionne en prenant la table en entrée (`epci_geo`), la table avec laquelle on souhaite définir les lignes à garder (`departement_44`),et l'opérateur qui va définir le test entre les deux géométries. Ici cet opérateur est `st_within(x,y)`, qui renvoie `TRUE` si la géométrie de `x` est contenue à l'intérieur de celle de `y`.

On peut spécifier différents prédicats spatiaux pour réaliser ce filtre.

En deuxième argument (`, ,`), on peut rajouter, comme dans une opération `[` classique de R les colonnes que l'on souhaite garder.

On voit ici que le résultat n'est pas très concluant :  il manque 3 epci du département, ceux qui sortent des frontières de celui-ci.
Prenons un buffer autour du département.

```{block2, type='rmdnote'}
Qu'est ce qu'un buffer ? C'est un tampon qui va nous permettre d'appliquer une transformation sur un objet vectoriel.

A partir d'une couche de départ de type ponctuel, linéaire ou polygonal, le buffer va créer une nouvelle couche vectorielle. La géométrie de cette couche représente des objets surfaciques dont les frontières sont positionnées à une distance euclidienne, définie par l'utilisateur, des limites des objets vectoriels de la couche de départ.
```

La fonction qui permet de faire cela avec `sf` s'appelle `st_buffer()`.

`st_buffer()` prend en paramètre : 

- un objet de classe *sf* 
- une distance dont l'unité est définie par celle de l'objet `sf`, que l'on peut obtenir comme ceci `st_crs(x)$units`.

```{r}
departement_44_buffer <- departement_44 %>%
  st_buffer(dist = 5000)

mapview(list(departement_44_buffer, departement_44), layer.name = c("Loire-Atlantique avec un buffer de 5 km", "Loire-Atlantique"), zcol = list("NOM_DEP", "NOM_DEP"), col.regions = list("#440154FF", "#FDE725FF"), legend = FALSE)
```

```{r}
epci_d44_buffer <- epci_geo[departement_44_buffer, , op = st_within]

mapview(list(departement_44_buffer, epci_d44_buffer), zcol = list("NOM_DEP", "NOM_EPCI"), legend = F)
```

On récupère 2 des 3 epci manquant ainsi. Celui qui manque est l'Epci de Redon qui est à cheval sur la Loire-Atlantique, le Morbihan et l'Ile et Vilaine.
Une méthode pour le récupérer est de prendre l'opérateur de filtre `st_intersect` au lieu de `st_within` en utilisant un buffer légèrement négatif de notre département pour ne pas récupérer les epci limitrophes.

```{r}
departement_44_buffer_negatif <- departement_44 %>%
  st_buffer(dist = -2000)

epci_d44 <- epci_geo[departement_44_buffer_negatif, , op = st_intersects]

mapview(list(departement_44, epci_d44), zcol = list("NOM_DEP", "NOM_EPCI"), legend = F)
```

## Prédicats spatiaux

Les prédicats spatiaux décrivent les relations spatiales entre objets. Pour bien les illustrer on va utiliser quelques données de test.
Nous allons utiliser un polygone (a), des lignes (l) et des points (p).

```{r}
# polygone (a)
a_poly <- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a <- st_sfc(a_poly)
# ligne (l)
l1 <- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1))))
l2 <- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0))))
l <- st_sfc(l1, l2)

# multipoints (p)
p_matrix <- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2)
p_multi <- st_multipoint(x = p_matrix)
p <- st_cast(st_sfc(p_multi), "POINT")
```

```{r,echo = F}
ggplot() + geom_sf(data = a, color = "red") + geom_sf(data = p) + geom_sf(data = l, color = "green") + theme_minimal()
```

A partir de ces objets, on peut se poser les questions suivantes :

- Quels sont les points de `p` contenus dans le triangle `a` ?

- Quels sont les points de `p` qui ne sont pas contenus dans le triangle `a` ?

- Quels sont les points de `p` qui touchent le triangle `a` ?

- Quelles sont les lignes de `l` contenues dans `a` ?


Les prédicats spatiaux vont nous permettre de répondre à ces questions. `sf` contient une liste de fonctions qui permettent chacune de répondre à l'une ou l'autre de ces questions.

`st_intersects()` permet de répondre à la première question, à savoir quels points de `p` sont dans `a`.

```{r}
st_intersects(p, a)
```

L'opposé de `st_intersects()` est `st_disjoint()` :  `st_disjoint(x,y)` renvoie `TRUE` pour les objets de `x` non reliés à `y`.

```{r}
st_disjoint(p, a)
```

Le résultat de cette opération est une liste. Par défaut, la fonction `st_intersect()` renvoie une *matrice creuse*^[https://fr.wikipedia.org/wiki/Matrice_creuse]. Cette structure permet d'économiser de la mémoire en n'enregistrant que les relations qui existent. Sur une opération de ce type, le gain est peu évident, mais quand on travail sur des objets plus complexes, le gain est appréciable.

Si on souhaite mieux utiliser cette information, on peut vouloir privilégier la *matrice dense*, qui renvoie une matrice de booléen pour chaque relation possible.

Pour cela on peut utiliser l'option `sparse=F`.

```{r}
st_intersects(p, a, sparse = F)
```

`st_within()` est une variante de `st_intersect()` qui ne renvoie `TRUE` que pour les points *à l'intérieur* du polygone.

```{r}
st_within(p, a, sparse = F)
```

Une variante de `st_within()` permet d'ajouter un critère de distance pour intégrer des points *presque* dans le polygone, `st_is_within_distance()`.

```{r}
st_is_within_distance(p, a, dist = 0.8)
```

`st_touches()` permet de récupérer les points qui *touchent* le polygone sans sans être à l'intérieur du polygone.

```{r}
st_touches(p, a, sparse = F)
```

`st_contains(x,y)` est équivalent à `st_within(y,x)`. Par exemple si nous voulons savoir lesquelles de nos lignes `l` sont contenues dans `a`.

```{r}
st_contains(a, l, sparse = F)
```

Equivalent à :

```{r}
st_within(l, a, sparse = F)
```

`st_crosses()`  renvoie TRUE si l'intersection des deux géométries est une géométrie de dimension n-1 ou n est le maximum des dimensions des deux objets et si l'intersection est à l'intérieur des deux objets.

```{r}
st_crosses(l, a, sparse = F)
```

Il existent encore d'autres prédicats qu'on ne détaillera pas ici : 

- `st_covers()`

- `st_covered_by()`

- `st_equals()` et `st_equals_exact()`

- `st_contains_properly()`

- `st_overlaps()`

### Exercices

- Créer un objet des points de p qui intersectent avec le polygone a


## Les jointures spatiales

Les jointures *attributaires*  se basent sur un appariement sur une liste des variables présentes dans les deux tables.

Les jointures spatiales se basent sur un appariement sur un espace geographique commun.

### Jointure de points avec des polygones

Ce cas est relativement simple, une jointure spatiale entre une liste de points et une liste de polygones va attribuer pour chaque point le polygone auquel il appartient.

On va utiliser ici le fichier sirene du département de Loire Atlantique géocodé par Christian Quest^[http://data.cquest.org/geo_sirene/].
Prenons les entreprises de production de sel sur ce département et regardons dans quelle partie du territoire elles se trouvent.

```{r}
load("data/sirene.RData")
sirene44_sel <- sirene44 %>%
  filter(APET700 == "0893Z")

mapview(list(departement_44, epci_d44, sirene44_sel), zcol = list("NOM_DEP", "NOM_EPCI", "NOMEN_LONG"), legend = F)
```

Nous allons réaliser une jointure spatiale pour récupérer le code sirene de l'EPCI où se trouve chaque entreprise.

```{r}
sirene44_sel_avec_code_epci <- sirene44_sel %>%
  st_join(epci_geo)
```

```{r}
mapview(list(departement_44, epci_d44, sirene44_sel_avec_code_epci), zcol = list("NOM_DEP", "NOM_EPCI", "NOM_EPCI"), legend = F)
```

```{block2, type='rmdnote'}
Une jointure entre deux couches de données géographique demande à ce que celles-ci partagent la même projection.
```

### Jointure de polygones avec des polygones

A la différence des appariements entre points et polygones, la jointure spatiales entre deux couches de polygones nécessite quelques critères complémentaires : souhaite-t-on joindre deux polygones dès qu'ils s'intersectent ? Souhaite-t-on joindre à un polygone de la première couche à celui de la deuxième avec lequel il partage le plus de surface en commun ?

Par exemple, imaginons que nous voulions joindre notre couche des epci avec celle des départements, souhaite-t-on que l'EPCI de Redon se retrouve apparié avec tous les départements dans lesquels il se retrouve, ou seulement le département dans lequel il est principalement situé ?

```{r}
epci_d44_avec_departement <- epci_d44 %>%
  st_join(departements_geo %>% st_buffer(dist = -1000))

epci_d44_avec_departement %>%
  select(NOM_EPCI, NOM_DEP) %>%
  group_by(NOM_EPCI) %>%
  tally() %>%
  arrange(-n)
```

Une jointure classique va donc rattacher 3 epci à plus de 1 département.

Avec l'option `largest = TRUE` la jointure va attribuer aux epci le département avec lequel il partage le plus de surface.
On voit ici que tout les epci adhérents à la Loire Atlantique se retrouvent alors rattachés à la Loire Atlantique.

```{r}
epci_d44_avec_departement <- epci_d44 %>%
  st_join(departements_geo %>% st_buffer(dist = -1000), largest = TRUE)

mapview(list(departement_44, epci_d44, sirene44_sel_avec_code_epci), zcol = list("NOM_DEP", "NOM_EPCI", "NOM_EPCI"), 
        legend = FALSE)
```

### Exercice

Le but de cet exercice va être d'exploiter les données *DVF* sur les transactions immobilières dans l'ancien et la carte des quartiers de Nantes pour obtenir un prix moyen des transactions par quartier.
On va utiliser pour DVF l'API mise en place par Christian Quest.

- Données DVF : http://api.cquest.org/dvf 

- Contour des quartiers de Nantes : https://data.nantesmetropole.fr/explore/dataset/244400404_quartiers-nantes/information/?disjunctive.nom

On veut produire les infos suivantes par quartier et année :

- Volume de ventes
- Pourcentage de maisons dans les ventes
- Prix moyen au m2 par type de bien

## Les calculs de distance

### Matrice de distances

Contrairement aux opérations précédentes qui sont binaires, les opérations de distance sont continues.

Les distances se calculent avec la fonction `st_distance()`.

```{r,warning = F}
centres_departements_pdl <- st_centroid(departements_geo) %>%
  filter(INSEE_REG == "52")

st_distance(centres_departements_pdl)
```

Trois choses à noter sur le résultat :

- `st_distance()` retourne une *matrice*...

- ... contenant toute les distances calculables 2 à 2...

- ...et qui a un paramètre `Units` nous donnant l'unité de mesure des distances calculées.

Ici on calcule notre matrice sur un seul objet. Vous pouvez calculer des distances entre deux objets `x` et `y` de classe `sf`. Dans ce cas il fera le calcul des distances pour toutes les combinaisons possibles d'objets de `x` et de `y`. Une option de `st_distance()` vous permet de limiter le résultat aux calculs 2 à 2 : `by_element = T`. Dans ce cas le résultat est un vecteur.

### Identification du plus proche voisin

Un besoin fréquent en traitement géomatique est d'identifier l'objet le plus proche d'un autre.
La fonction qui permet cela est `st_nearest_feature()`.

Prenons l'ensemble des départements français, et trouvons celui de la région le plus proche. On va utiliser les centroïdes pour alléger le calcul.

```{r}
index_dep_pdl <- st_nearest_feature(
  departements_geo,
  centres_departements_pdl
)
```

`st_nearest_feature()` renvoie un vecteur d'index en résultat. 

Pour visualiser cet index, vous pouvez utiliser ensuite la fonction `st_nearest_point()` qui va permettre de faire un lien entre les départements et le département ligérien le plus proche.

`st_nearest_point()` permet en effet de renvoyer pour deux géométries la ligne rejoignant les 2 points les plus proches.

```{r}
liens <- st_nearest_points(departements_geo,
  centres_departements_pdl[index_dep_pdl, ],
  pairwise = TRUE
)

ggplot() +
  geom_sf(data = departements_geo) +
  geom_sf(data = liens)
```

On peut utiliser aussi `st_nearest_feature()` comme un mode de jointure des données.

```{r}
departements_join <- st_join(departements_geo,
  centres_departements_pdl,
  join = st_nearest_feature
)

ggplot() +
  geom_sf(data = departements_join, aes(fill = NOM_DEP.y)) +
  labs(
    title = "Département ligérien le plus proche de chaque département français",
    fill = NULL
  )
```


<!--chapter:end:06-les-operations-sur-donnees-spatiales.Rmd-->

# Les opérations géométriques

Nous allons voir dans ce chapitre comment opérer des opérations géométriques sur nos vecteurs.

Dans ce chapitre, nous allons utiliser les packages suivants.

```{r}
library(sf)
library(tidyverse)
library(mapview)
library(ggplot2)
library(rmapshaper)
```

On distingue deux types d'opérations : les opérations unaires et binaires.


## Opérations unaires

### Simplification

La simplification revient comme son nom l'indique à simplifier une couche vectorielle. Le cas d'usage d'un tel procédé peut être un changement d'échelle et plus généralement le besoin de réduire la taille de stockage de notre objet (par exemple pour une publication ou une carte interactive).

Le package `sf` contient une fonction `st_simplify` qui implémente l'algorithme de Douglas-Peucker^[Douglas, David H, and Thomas K Peucker. 1973. “Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or Its Caricature.” Cartographica: The International Journal for Geographic Information and Geovisualization 10 (2): 112–22.] de GEOS.

La fonction utilise le paramètre `dTolerance` pour controler le niveau de simplification.

```{r}
load("data/admin_express.RData")

departement_56 <- departements_geo %>%
  filter(INSEE_DEP == "56")

departement_56_simplifie <- departement_56 %>%
  st_simplify(dTolerance = 900)

departement_56_super_simplifie <- departement_56 %>%
  st_simplify(dTolerance = 2000)
```

```{r,echo=TRUE,}
p1 <- ggplot() + 
  geom_sf(data = departement_56) + 
  theme_void() + 
  theme(panel.grid = element_blank(), panel.border = element_blank())

p2 <- ggplot() + 
  geom_sf(data = departement_56_simplifie) +
  theme_void()

p3 <- ggplot() + 
  geom_sf(data = departement_56_super_simplifie) + 
  theme_void()

p1 + p2 + p3 + plot_layout(nrow = 1)
```

On peut mesurer le gain réalisé par chaque opération.

- Une simplification avec un `dTolerance` de 900 permet d'économiser `r - round(100*object.size(departement_56_simplifie)/object.size(departement_56)-100,1)` % du stockage.

- Une simplification avec un `dTolerance` de 2000 permet d'économiser `r - round(100*object.size(departement_56_super_simplifie)/object.size(departement_56)-100,1)` % du stockage.

```{r}
object.size(departement_56)
object.size(departement_56_simplifie)
object.size(departement_56_super_simplifie)
```

Le problème de l'algorithme Douglas-Peucker est qu'il simplifie les géométries objet par objet. Cela conduit à perdre la topologie, et à des trous ou des chevauchements. L'option `preserveTopology = T` de `st_simplify()` doit permettre en théorie d'éviter ce problème, mais ne marche pas au delà d'un certain seuil.

Par exemple, prenons 2 départements autour du Morbihan.

```{r}
departements_35_44_56 <- departements_geo %>%
  filter(INSEE_DEP %in% c("35", "44", "56"))

departements_35_44_56_super_simplifie <- departements_35_44_56 %>%
  st_simplify(dTolerance = 3000)
```

```{r}
p1 <- ggplot() + 
  geom_sf(data = departements_35_44_56) + 
  theme_void() + 
  theme(panel.grid = element_blank(), panel.border = element_blank())

p3 <- ggplot() + 
  geom_sf(data = departements_35_44_56_super_simplifie) + 
  theme_void()

p1 + p3 + plot_layout(nrow = 1)
```

On constate clairement des trous à la frontière des 3 départements.

Un autre algorithme peut être utilisé qui n'a pas les mêmes limitations, l'algorithme de Visvalingam^[Visvalingam, M., and J. D. Whyatt. 1993. “Line Generalisation by Repeated Elimination of Points.” The Cartographic Journal 30 (1): 46–51. https://doi.org/10.1179/000870493786962263.].

Le package `rmapshaper` contient une fonction `ms_simplify()` qui implémente cet algorithme.
Ce package est une interface vers Mapshaper^[https://mapshaper.org/], un site en ligne d'édition de données cartographiques.

```{r}
departements_35_44_56 <- departements_35_44_56 %>%
  mutate(AREA = as.numeric(AREA))
departements_35_44_56_ms_simplifie <- ms_simplify(departements_35_44_56, method = "vis", keep = 0.01)
```

```{r}
p1 <- ggplot() + 
  geom_sf(data = departements_35_44_56) + 
  theme_void() + 
  theme(panel.grid = element_blank(), panel.border = element_blank())

p3 <- ggplot() + 
  geom_sf(data = departements_35_44_56_ms_simplifie) + 
  theme_void()

p1 + p3 + plot_layout(nrow = 1)
```

### Centroïde
  
Le centroïde permet d'identifier le centre d'un objet géométrique. Il y a plusieurs façons de définir un centroïde. La plus usuelle est le centroïde géographique, qui peut être défini comme le point d'équilibre d'un objet (celui en dessous duquel votre doigt peut faire tenir en équilibre cet objet).
La fonction permettant de définir un centroïde dans `sf` est `st_centroid()`.

```{r}
centres_departements <- st_centroid(departements_geo)
```

```{r}
ggplot() +
  geom_sf(data = departements_geo) +
  geom_sf(data = centres_departements, color = "dark green", size = .5) +
  theme_void() +
  theme(panel.grid = element_blank(), panel.border = element_blank()) +
  labs(title = "les départements et leur centroïdes")
```

Parfois, le centroïde peut se placer en dehors de l'objet lui même. Par exemple pensez à un atoll.

![](pic/atoll.jpg)

Dans ce cas on peut utiliser `st_point_on_surface()` qui garantit que le point est sur la surface de l'objet de départ.

### Buffer

Comme déjà vu, à partir d'une couche de départ de type ponctuel, linéaire ou polygonal, le buffer va créer une nouvelle couche vectorielle. La géométrie de cette couche représente des objets surfaciques dont les frontières sont positionnées à une distance euclidienne, définie par l'utilisateur, des limites des objets vectoriels de la couche de départ.

```{r}
departement_44_buffer <- departement_44 %>%
  st_buffer(dist = 5000)

mapview(list(departement_44_buffer, departement_44), layer.name = list("Loire-Atlantique avec un buffer de 5 km", "Loire-Atlantique"), zcol = list("NOM_DEP", "NOM_DEP"), col.regions = list("#440154FF", "#FDE725FF"), legend = FALSE)
```

## Opérations binaires

### Transformation affine

Les tranformations affines regrouppent les transformations qui préservent les lignes et le parallélisme. A l'inverse les angles et les tailles ne le sont pas forcément.

Les transformations affines intègrent notamment les translations, les rotations et les changements d'échelle.

Le package `sf` implémente ces transformations pour les objets de classe `sfg` et `sfc`.

#### Translation

```{r}
departement_44_sfc <- st_geometry(departement_44)

departement_44_sfc_trans <- departement_44_sfc + c(10000, 10000)

departement_44_trans <- st_set_geometry(departement_44, departement_44_sfc_trans)

st_crs(departement_44_trans) <- st_crs(departement_44)

mapview(list(departement_44_trans, departement_44), layer.name = list("Loire-Atlantique avec déplacement affine de 10 km vers le nord et 10 km vers le sud", "Loire-Atlantique"), zcol = list("NOM_DEP", "NOM_DEP"), col.regions = list("#440154FF", "#FDE725FF"), legend = FALSE)
```

#### Changement d'échelle

Dans l'exemple suivant on va réduire par deux la surface de chacun des epci du département.
Pour cela on va recentrer les epci pour que les coodonnées des centroids soient à l'origine avant de diviser par deux les cordonnées des contours et réappliquer la translation au centroid.

```{r}

epci_d44_sfc <- st_geometry(epci_d44)

epci_d44_centroid_sfc <- st_centroid(epci_d44_sfc)

epci_d44_centroid_sfc_scale <- (epci_d44_sfc - epci_d44_centroid_sfc) * 0.5 + epci_d44_centroid_sfc

epci_d44_centroid_scale <- st_set_geometry(epci_d44, epci_d44_centroid_sfc_scale)

st_crs(epci_d44_centroid_scale) <- st_crs(epci_d44)


mapview(list(epci_d44, epci_d44_centroid_scale), layer.name = list("Epci de Loire-Atlantique", "Epci de Loire-Atlantique avec surface divisées par deux"), zcol = list("NOM_EPCI", "NOM_EPCI"), col.regions = list("#440154FF", "#FDE725FF"), legend = FALSE)
```


### Découpage

Le découpage spatiale est une forme de filtre sur les géographies.

Le découpage peut seulement s'appliquer à des formes plus complexes que des points : (multi-)lignes, (multi-)polygones.

Nous allons illustrer le découpage à partir des epci à cheval sur plusieurs départements.

```{r}
epci_redon <- epci_d44 %>%
  filter(CODE_EPCI == "243500741")
```

```{r, echo=F}
ggplot() +
  geom_sf(data = departement_44) +
  geom_sf(data = epci_redon) +
  geom_sf_label(data = epci_redon, aes(label = NOM_EPCI)) +
  geom_sf_label(data = departement_44, aes(label = NOM_DEP))
```


`st_intersection()` permet de ne garder que la partie commune des deux géométries

```{r,warning=F, message=F}
redon_et_departement_44 <- st_intersection(epci_redon, departement_44) %>%
  mutate(NOM_EPCI = "Communes du 44 de la CA Redon Agglomération")
```

```{r,echo=F}
ggplot() +
  geom_sf(data = epci_redon) +
  geom_sf(data = departement_44) +
  geom_sf(data = redon_et_departement_44, fill = "grey") +
  geom_sf_label(data = epci_redon, aes(label = NOM_EPCI)) +
  geom_sf_label(data = departement_44, aes(label = NOM_DEP))
```

`st_difference(x,y)` permet de ne garder que la partie de `x` non présente dans `y`

```{r,warning=F,message=F}
redon_hors_departement_44 <- st_difference(epci_redon, departement_44) %>%
  mutate(NOM_EPCI = "Communes du 44 et du CA Redon Agglomération hors communes en commun")
```

```{r,echo=F}

ggplot() +
  geom_sf(data = epci_redon) +
  geom_sf(data = departement_44) +
  geom_sf(data = redon_hors_departement_44, fill = "grey") +
  geom_sf_label(data = epci_redon, aes(label = NOM_EPCI)) +
  #  geom_sf_label(data=redon_et_departement_44_sans_partie_communes,aes(label = NOM_EPCI))+
  geom_sf_label(data = departement_44, aes(label = NOM_DEP))
```

`st_sym_difference(x,y)` permet de ne garder que les partie de `x` et de `y` non communes.

```{r,warning=F,message=F}
redon_et_departement_44_sans_partie_communes <- st_sym_difference(epci_redon, departement_44) %>%
  mutate(NOM_EPCI = "Communes du 44 et du CA Redon Agglomération hors communes en commun")
```

```{r,echo=F}

ggplot() +
  geom_sf(data = epci_redon) +
  geom_sf(data = departement_44) +
  geom_sf(data = redon_et_departement_44_sans_partie_communes, fill = "grey") +
  geom_sf_label(data = epci_redon, aes(label = NOM_EPCI)) +
  #  geom_sf_label(data=redon_et_departement_44_sans_partie_communes,aes(label = NOM_EPCI))+
  geom_sf_label(data = departement_44, aes(label = NOM_DEP))
```

### Union

Union permet de fusionner les géométries de plusieurs objets.
On va regarder comment reconsituer la carte des communes à partir de celle des départements

```{r}
regions <- departements_geo %>%
  group_by(INSEE_REG) %>%
  summarise(do_union = T)
```

```{r}
mapview(regions, legend = F)
```

Derrière cette opération, `summarise()` utilise `st_union()` du package `sf` pour dissourdre les polygones des départements en un seul polygone régional.

```{r}
regions_52 <- departements_geo %>%
  filter(INSEE_REG == "52")

regions_52 <- st_union(regions_52)
```


<!--chapter:end:07-operations-geometriques.Rmd-->

# Les reprojections

Dans ce chapitre, nous allons utiliser les librairies suivantes.

```{r}
library(sf)
library(tidyverse)
library(ggplot2)
library(patchwork)
library(lwgeom)
```


Pour rappel, il existe deux types de CRS, les CRS géographiques (longitude/lattitude avec pour unité de compte des degrés) et les CRS projetés (avec un datum et une unité en mètre par exemple).

La plupart des fonctions de `sf` présupposent s'appliquer sur un CRS projeté, car les fonctions de GEOS sur lesquelles elles se basent le font aussi.

## Un premier exemple de reprojection

Prenons les coordonnées de Nantes en WGS 84: 

```{r}
nantes<-data.frame(lon=-1.553621,lat=47.218371) %>% 
    st_as_sf(coords = c("lon", "lat")) %>% 
  st_set_crs(4326)
```

On peut visualiser nos données

```{r}
mapview(nantes)
```


`st_is_longlat()` est une fonction de `sf` qui permet de faire un test sur la famille de CRS à laquelle on a à faire.

```{r}
st_is_longlat(nantes)
```

Essayons de créer un buffer de 1km autour de Nantes

```{r,warning=T}
nantes_buffer= st_buffer(nantes, dist = 1)
```

```{r}
mapview(list(nantes,nantes_buffer))
```

Le message est clair et indique qu'un buffer ne marchera pas correctement sur des données en projection longitude / lattitude.

Tentons une reprojection. La fonction permettant une reprojection est `st_transform()`.
On va ici passer en lambert 93 nos données.

```{r}
nantes_proj<-st_transform(nantes, 2154)
```

Le CRS lambert 93 est bien un CRS projeté : 

```{r}
st_is_longlat(nantes_proj)
```

```{r,warning=T}
nantes_proj_buffer= st_buffer(nantes_proj, dist = 1)
```

```{r}
mapview(list(nantes_proj,nantes_proj_buffer))
```

## Quand reprojeter ?

Quelques cas usuels qui peuvent vous amener à reprojeter vos données : 

- la manipulation de données fournies dans des CRS différents

- l'usage du package leaflet impose des données spécifiées en WGS 84

- le besoin de visualiser vos données suivant la conversion de certaines propriétés des objets à la surface de la terre.

- l'usage de fonctions demandant à utiliser des CRS projetés (comme `st_buffer()` ci-dessus)

Un exemple d'usage : la distance de Rennes à Nantes

Prenons les coordonnées WGS 84 de Rennes

```{r}
rennes<-data.frame(lon=-1.6777926,lat=48.117266) %>% 
    st_as_sf(coords = c("lon", "lat")) %>% 
  st_set_crs(4326)
```

```{r}
mapview(rennes)
```

Tentons de calculer la distance de Rennes à Nantes.
Avec la données en Lambert 93, la fonction `st_distance()` renvoie un message d'erreur.

```{r,error=T}
st_distance(rennes,nantes_proj)
```

Avec la données en WGS 84, la fonction `st_distance()` renvoie bien le résultat.

```{r,error=T}
st_distance(rennes,nantes)
```

## Quel CRS utiliser ?

A cette question, il y a rarement une bonne réponse.

En ce qui concerne les CRS géométriques, le plus simple est d'utiliser le WGS 84, qui est de loin le plus populaire, avec lequel beaucoup de données sont fournies.

En ce qui concerne les CRS projetés, utiliser par défaut le lambert 93, le CRS officiel français, pour les données nationales fait sens.

Ensuite votre choix va dépendre des propriétés que vous souhaitez conserver.

## Comment projeter ?

### Projeter des vecteurs

Reprojeter des données vecteur se fait à l'aide de la fonction `st_transform()` que nous avons vu en utilisant le code epsg que nous voulons.

### Modifier la projection d'une carte.

Parfois on souhaite pouvoir aller plus loin dans les reprojections, en adaptant le centre de la projection, pour cela on peut utiliser un `proj4string` ad hoc.

Pour cela, on va modifier l'argument `+proj` de notre crs avec `st_transform`.

Tentons par exemple de reprojeter notre carte du globe en utilisant la projection azimutale équivalente de Lambert, centrée sur Pékin.

```{r}
data("World")
World_pekin<-st_transform(World,crs = "+proj=laea +x_0=0 +y_0=0 +lon_0=116 +lat_0=40")
```

Le paramètre `+proj=laea` permet de redéfinir la projection, les paramètres `+lon_0` et `lat_0` permettent de définir le centre de la projection. `x_0` et `y_0` définissent le centre du plan pour les coordonnées.

Qu'est ce qui a changé entre nos deux cartes ?

```{r}
st_crs(World)
st_crs(World_pekin)
```

```{r,echo = F}
p1<-ggplot()+
  geom_sf(data=World)
p2<-ggplot()+
  geom_sf(data=World_pekin)
p1+p2+plot_layout(nrow=1)
```


<!--chapter:end:08-les-reprojections.Rmd-->

# (PART) Créer des cartes sous R {-}

# Créer des cartes avec ggplot2
Dans ce chapitre, nous allons utiliser les librairies suivantes.

```{r, eval=T,echo=F}
theme_set(theme_gray())
```

```{r}
library(sf)
library(tidyverse)
library(ggplot2)
library(patchwork)
library(lwgeom)
#remotes::install_github("MaelTheuliere/variousdata")
library(variousdata)
library(ggspatial)
```

## Quelques rappels sur ggplot2

### Présentation du package ggplot2


- [ggplot 2](http://ggplot2.tidyverse.org/) est un package créé par Hadley Wickham et Winston Chang pour implémenter dans R la vision développée par Leland Wilkinson dans  [The Grammar of Graphics (Statistics and Computing)](https://www.amazon.com/Grammar-Graphics-Statistics-Computing/dp/0387245448/ref=as_li_ss_tl?ie=UTF8&qid=1477928463&sr=8-1&keywords=the+grammar+of+graphics&linkCode=sl1&tag=ggplot2-20&linkId=f0130e557161b83fbe97ba0e9175c431) de la conception de graphiques.

- Le but est de fournir une approche unique pour produire quasiment **toute valorisation graphique** de données que l'on peut trouver dans des revues scientifiques, les journaux, dans l'analyse statistique ou la data visualisation.

- Ce package aujourd'hui s'inscrit dans R dans le **framework Tidyverse** qui propose une approche cohérente sur l'ensemble de la chaîne de vie de la donnée : importation, préparation des données, analyse et valorisation.

### Le Tidyverse
![le tidyverse](pic/tidyverse.png "le tidyverse"){#id .class width=800}

### ggplot 2 : les concepts clefs

Pour construire un graphique avec ggplot il va falloir lui définir plusieurs éléments : 

- **la donnée** : ggplot2 permet de travailler sur des vecteurs, des dataframes, des tibbles, ou des données spatiales ;

- le **mapping** : on définit dans l'aesthetic (ou aes) le **mapping**, c'est à dire ce que l'on veut représenter qui **dépend des variables** (quelle variable sur l'axe x, sur l'axe y, quelle variable pour définir une graduation de couleurs...) ;

- les **paramètres** : on définit les autres paramètres qui dépendent de constantes (par exemple : je veux que toutes mes lignes soient rouges ou de taille 2 pixels) ;

- le **layer ("forme géométrique")** : on définit sous quelle représentation graphique on représente les paramètres précédents. Sous ggplot, ces fonctions sont de la forme geom_XX ;

L'écriture type d'un graphique sera donc: 

```{r, echo=T,eval=F}
ggplot(data = <DATA>) + 
  <FORME_GEO>(mapping = aes(<MAPPINGS>),...=<PARAMS>)
```

On va ensuite pouvoir partir de cette base pour l'enrichir avec des fonctions supplémentaires.
Chaque fonction s'enchaine avec des `+` comme les `%>% `.

```{r, echo=T,eval=F}
ggplot(data = <DATA>) + 
  <FORME_GEO>(mapping = aes(<MAPPINGS>),...=<PARAMS>)+
  <FONCTION1>+
  ...
```

### Le mapping

#### Les paramètres du mapping

Dans l'exemple qui suit, la représentation géographique utilisée est le nuage de point `geom_point()`.
D'autres types de représentations graphiques sont présentées dans la partie suivante.

L'aesthetic sert à identifier les variables que l'on souhaite représenter.
Par exemple, si l'on souhaite représenter le taux de mortalité maternelle (Maternal_mortality_ratio) en fonction du produit intérieur brut (Gross_Domestic_Product_GDP) :

```{r, fig.height=3.5, warning = F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
    geom_point(aes(x = gdp_per_cap, y = sh_sta_mmr))

```

De plus, la fonction `aes()` admet d'autres arguments qui permettent de modifier l'apparence du graphique selon une 3ème variable du jeu de données.

- `colour` : la couleur,
- `shape` : la forme,
- `size` : la taille,
- `alpha` : la transparence,
- `fill` : le remplissage ;

```{r, fig.height=3.5,warning = F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent))
```

#### Les "autres" paramètres

Il est possible de spécifier des paramètres qui seront valables pour l'ensemble du graphique. 
On retrouve entre autre les mêmes paramètres que proposés dans l'aes mais il faut alors les passer **en dehors de l'aesthetic**.

Par exemple si l'on souhaite modifier la transparance et la taille de l'ensemble des points du graphique précédent:

```{r, fig.height=3.5,warning = F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  )
```

De même si l'on souhaite modifier la couleur générale:

```{r, fig.height=3.5,warning = F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr),
    color = "red",
    alpha = 0.5, 
    size = 1.9
  )
```

Pour choisir et modifier facilement les couleurs d'un graphique, il existe un addin développé par Dean Attali: `Colour Picker`.

Il est installable comme n'importe quel package.

Pour plus d'informations: https://github.com/daattali/colourpicker


### L'habillage simple

#### Titre et libellé des axes

Chaque nouvel élément graphique est à rajouter sous forme de layer, ici nous utilisons la fonction `labs()` qui permet de labelliser tout les éléments possibles de l'aesthétic, ainsi que le titre (`title`), le sous titre (`subtitle`) et le bas de page (`caption`)

```{r, echo=T,eval=T,fig.height=5,fig.width=10,warning=F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  )
```

A noter qu'il existe plusieurs autres façons de spécifier ces élèments par des fonctions spécifiques: ggtitle, xlab, ylab,...

#### Légende

Les fonctions `guide()` et `guides` permettent de modifier finement la légende.
Les guides peuvent être spécifiées dans chaque `scale_` ou dans une instruction `guides`.

```{r, echo=T,eval=T,fig.height=5,fig.width=10,warning=F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  guides(color = guide_legend(
    direction = "horizontal",
    order = 1,
    title.position = "top",
    title.hjust = 0.5,
    nrow = 1,
    label.position = "bottom"
  )) +
  theme(legend.position = "bottom")
```

#### Annotation

Il est aussi possible de rajouter des annotations de type texte, par exemple, "à la volée".

```{r, echo=T,eval=T,fig.height=5,fig.width=10,warning=F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  annotate("text", x = 100000, y = 2, label = "je rajoute mon texte", color = "blue")

```

La fonction `annotate()` permet aussi d'ajouter d'autres types d'annotation comme par exemple des rectangles:

```{r, echo=T,eval=T,fig.height=5,fig.width=10,warning=F}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  annotate("rect", xmin = 10, xmax = Inf, ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.2) +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 2, fill = "green", alpha = 0.2)
```

### Les thèmes

Pour modifier simplement la position de la légende, c'est la fonction [`theme()`](http://ggplot2.tidyverse.org/reference/theme.html) qu'il faut utiliser.

`theme()` permet de créer des templates, c'est à dire de définir tout ce qui n'est pas lié directement aux données sur un graphique, notamment: 

- la position, taille,couleur,police des éléments textuels

- la couleur des grilles primaires et secondaires du graphique


Il existe des [thèmes prédéfinis](http://ggplot2.tidyverse.org/reference/index.html#section-themes) dans ggplot que l'on peut déjà utiliser.
Par exemple: `theme_classic()`, `theme_bw()`, `theme_dark()`, ...

Des packages externes permettent d'enrichir cette collection de thèmes, par exemple `ggthemes` ou `hrbrthemes`.

Lorsque l'on souhaite garder une cohérence entre plusieurs graphiques, le mieux est d'en définir un à part pour l'appeler ensuite.


#### Les fonctions "élément"

Elle utilise 4 types de fonctions:

- `element_text()` : pour toutes les étiquettes

PARAMÈTRE | VALEUR
----------| --------
family | la famille de la police 
face | le type de police ("plain", "italic", "bold", "bold.italic")
colour | couleur
size | taille en points
hjust | justification horizontale, dans [0, 1]
vjust | justification verticale, dans [0, 1]
angle | angle, dans [0, 360]
lineheight | hauteur de ligne (pour l’espacement entre les lignes)

- `element_rect()` : pour les fonds et les cadres,

PARAMÈTRE | VALEUR
----------| ---------------------------------------------------------------
fill | la couleur de remplissage
colour | la couleur de la bordure
size | la taille de la bordure
linetype | le type de ligne ("blank", "solid", "dashed", "dotted", "dotdash", "longdash", "twodash)

- `element_line()` : pour toutes les lignes tracées,

PARAMÈTRE | VALEUR
----------| ---------------------------------------------------------------
colour | la couleur de ligne
size | la taille
linetype | le type de ligne ("blank", "solid", "dashed", "dotted", "dotdash","longdash", "twodash)
lineend | le type de fin de ligne ("round", "butt" ou "square")


- `element_blank()` : permet de ne rien dessiner.

#### Les composantes

Il s'agit des différents éléments modifiables dans le thème.
Par exemple:

**Axes**
axis.line, axis.text.x, axis.text.y, axis.ticks, axis.title.x, axis.title.y,...

**Légende**
legend.background, legend.key, legend.text, legend.title,...

**Fond de graphe**
panel.background, panel.border, panel.grid.major, panel.grid.minor,...

 etc

#### Quelques exemples 

- Changer le fond du graphique `panel_background()`

```{r, echo=T,eval=T,warning=FALSE,fig.height=5,fig.width=10}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  theme(panel.background = element_rect(fill = "Lavender", colour = "black"))
```

- Changer l'apparence du quadrillage : `panel_background()`

```{r, echo=T,eval=T,warning=FALSE,fig.height=5,fig.width=10}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  theme(panel.grid.major = element_line(colour = "gray", size = 0.5, linetype = "dashed"))
```

- Changer l'apparence des étiquettes des axes  : `axis_xxx()`

```{r, echo=T,eval=T,warning=FALSE,fig.height=5,fig.width=10}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  theme(
    axis.text.x = element_text(colour = "blue", angle = 45),
    axis.title = element_text(face = "bold", colour = "orange")
  )
```

Certains changements de paramètres ne nécessitent pas l'utilisation de fonctions `element_()`.
Par exemple, pour changer la position de la légende :  `legend.xxx()`

```{r, echo=T,eval=T,warning=FALSE,fig.height=5,fig.width=10}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  theme(legend.position = "left", legend.title = element_blank())
```

#### Modifier le thème par défaut.

La fonction `theme_set()` vous permet de définir un thème par défaut pour l'ensemble de vos graphiques.

```{r, echo=T,eval=T,warning=FALSE,fig.height=5,fig.width=10}
theme_set(theme_dark())

sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  )
```


#### Créer son propre thème

Un thème est une fonction R qui va prendre en paramètre des éléments que vous souhaitez pouvoir faire varier et fixer des éléments que vous souhaitez avoir comme rendu par défaut.

Créons ici un thème avec un fond vert pour le ministère de la transition écologique et solidaire. On rajoute un paramètre pour la taille de la police du titre du graphique.

```{r,warning=FALSE}
theme_mtes <- function(taille_police = 14) {
  theme_bw() +
    theme(
      plot.title = element_text(color = "white", size = taille_police, face = "bold"),
      text = element_text(color = "white"),
      axis.text = element_text(color = "white"),
      panel.background = element_rect(fill = "lightgreen", colour = "lightgreen"),
      plot.background = element_rect(fill = "#006400", colour = "lightgreen"),
      legend.background = element_rect(fill = "lightgreen", colour = "lightgreen"),
      legend.key = element_blank()
    )
}

sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  theme_mtes()
```


### Les scales

Les fonctions `scales()` permettent globalement de paramétrer les éléments rentrés dans l'aesthétic : 

- Si je veux un gradient de couleurs fonction d'une variable continue : quelle palette de couleurs je choisie, comment je cale mon dégradé en fonction de cette variable continue ?

- Si je met une variable continue en ordonnée, comment je définis le minimum et maximum de cette axe, sa position, les valeurs que j'affiche sur l'échelle...


L'ensemble des scales possibles peuvent se décrire sous la forme suivante:

`scale_xx_yy()`

ou `xx` peut être un des paramètres de l'aesthétic : 

xx|description
-----------------|---
alpha|transparence
color|couleur des lignes ou des points
fill|couleurs des aires
linetype|type de ligne (continue,pointillée,...)
shape|forme des points
size|aire des points
x|variable de l'axe x
y|variable de l'axe y


Et `yy` un type de paramétrage :  

yy|description
-----------------|--------------------------
continuous|gérer les variables continue
discrete|gérer les variables discrètes
date|gérer une variable au format date
reverse|inverser l'axe
log|convertire l'échelle d'une variable continue en échelle logarithmique
log10|convertire l'échelle d'une variable continue en échelle logarithmique décimale
viridis|utiliser une palette de couleur viridis
brewer|utiliser une palette de couleur brewer (variable discrète)
distiller|utiliser une palette de couleur brewer (variable continue)
gradient|utiliser un gradient de 2 couleurs
gradient2|utiliser un gradient divergent de 3 couleurs


```{r, echo=T,eval=T,fig.height=3.5}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  scale_color_brewer(type = "qual")
```

Par exemple on peut exploiter une fonction scale pour définir une échelle logarithimique sur un axe.

```{r, echo=T,eval=T,fig.height=3.5}
sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  scale_color_brewer(type = "qual") +
  scale_x_log10() +
  scale_y_log10()
```

#### Formatage spécifique

- Transformation en pourcentage;
```{r, echo=T,eval=F}
  scale_y_continuous(labels = scales::percent)
```

- Ajout du séparateur des milliers;
```{r, echo=T,eval=F}
scale_y_continuous(labels = function(x) format(x, big.mark = " ", scientific = FALSE))
```
- Ajout du symbole €;

```{r, echo=T,eval=F}
scale_y_continuous(labels = function(x) paste(x, " €"))
```



### La mise en page de plusieurs graphiques

Le package `cowplot` permet la combinaison de plusieurs graphiques. Il est composé de plusieurs fonctions.

- le fonction `plot_grid()` qui permet de disposer ***n*** graphes sur ***i*** colonnes et ***j*** lignes


```{r, echo=T,eval=T,warning=F,fig.height=3.5}
gg1 <- sdg_indicators %>% 
  filter(timeperiod ==2015) %>% 
  ggplot() +
  geom_point(aes(x = gdp_per_cap, 
                 y = sh_sta_mmr,
                 color = continent),
    alpha = 0.5, 
    size = 1.9
  ) +
  labs(
    title = "Mortalité maternelle en fonction du PIB par habitant",
    subtitle = "En 2015",
    x = "PIB par habitant",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances)",
    caption = "Source : ODD / ONU"
  ) +
  scale_x_log10() +
  scale_y_log10() +
  theme(axis.title = element_text(size = 9))

  gg2 <- sdg_indicators %>% 
    filter(timeperiod ==2015) %>% 
    ggplot()+
    geom_density(aes(x=gdp_per_cap))+
    scale_x_log10()

plot_grid(gg1, gg2, ncol = 1, nrow = 2)
```

- la fonction `draw_plot()` associée à `ggdraw()` qui permet de disposer les graphiques à des places spécifiques.

`ggdraw()` initialise le graphique

```{r, echo=T,eval=T,warning=F,fig.height=3.5}


gg3 <- sdg_indicators %>% 
    filter(timeperiod == 2015) %>% 
    ggplot() +
    geom_bar(aes(x = continent, fill = continent)) +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank()
  )
ggdraw() +
  draw_plot(gg1, x = 0, y = .5, width = 1, height = .5) +
  draw_plot(gg2, x = 0, y = 0, width = .3, height = .5) +
  draw_plot(gg3, x = 0.3, y = 0, width = 0.7, height = .5)
```

### Les facettes

Lorsque l'on veut pouvoir réaliser un graphique pour plusieurs sous-ensembles, les facettes sont alors très utiles. On va ici l'illustrer avec la réalisation du même graphique ci-dessus mais pour plusieurs années différentes.

```{r, echo=T,eval=T,warning = F,fig.height=5,fig.width=8}

sdg_indicators %>% 
  filter(timeperiod  %in% c(2000, 2005, 2010, 2015),
         geoareaname %in% c("France","Canada","Burkina Faso","China","Australia")) %>%
  ggplot() +
  geom_bar(aes(x = geoareaname, weight = sh_sta_mmr, fill = continent)) +
  theme_minimal() +
  scale_fill_viridis_d() +
  coord_flip() +
  scale_y_log10()+
  labs(
    title = "Mortalité maternelle sur quelques pays",
    subtitle = "En 2015",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances), échelle logarithmique",
    x = "Pays",
    fill = "Pays"
  ) +
  theme(legend.position = "none") +
  facet_wrap(~timeperiod)
```

L'exemple pris ici "scinde" notre table en fonction d'une seule variable, mais on peut le faire sur plusieurs variables également.

On peut choisir avec `facet_wrap()` : 

- le nombre de colonnes ou de ligne sur lesquel on veut voir s'afficher le graphique
- si on veut fixer l'échelle de l'un ou l'autre des axes ou les deux

```{r, echo=T,eval=T,fig.height=5,fig.width=12}
sdg_indicators %>% 
  filter(timeperiod  %in% c(2000, 2005, 2010, 2015),
         geoareaname %in% c("France","Canada","Burkina Faso","China","Australia")) %>%
  ggplot() +
  geom_bar(aes(x = geoareaname, weight = sh_sta_mmr, fill = continent)) +
  theme_minimal() +
  scale_fill_viridis_d() +
  coord_flip() +
  scale_y_log10()+
  labs(
    title = "Mortalité maternelle sur quelques pays",
    subtitle = "En 2015",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances), échelle logarithmique",
    x = "Pays",
    fill = "Pays"
  ) +
  theme(legend.position = "none") +
  facet_wrap(~timeperiod, ncol = 4)
```


### Exporter un graphique

ggplot contient une fonction `ggsave()` qui permet d'exporter nos graphiques au format image dans les formats suivants : eps, ps, tex (pictex), pdf, jpeg, tiff, png, bmp, svg or wmf 

```{r, echo=T,eval=F,fig.height=5,fig.width=12}
p <- sdg_indicators %>% 
  filter(timeperiod  %in% c(2000, 2005, 2010, 2015),
         geoareaname %in% c("France","Canada","Burkina Faso","China","Australia")) %>%
  ggplot() +
  geom_bar(aes(x = geoareaname, weight = sh_sta_mmr, fill = continent)) +
  theme_minimal() +
  scale_fill_viridis_d() +
  coord_flip() +
  scale_y_log10()+
  labs(
    title = "Mortalité maternelle sur quelques pays",
    subtitle = "En 2015",
    y = "Taux de mortalité de la mère \n(pour 100 000 naissances), échelle logarithmique",
    x = "Pays",
    fill = "Pays"
  ) +
  theme(legend.position = "none") +
  facet_wrap(~timeperiod, ncol = 4)

ggsave("figures/Mortalité maternelle sur quelques pays du globe.svg", p, width = 12, height = 5)
```

## Faire des cartes avec ggplot2

### Les cartes choroplèthe

ggplot2 intègre une fonction geom permettant l'utilisation de données géomatrique : `geom_sf()`

Celle ci doit se coupler avec la fonction `coord_sf()` qui permet de s'assurer en cas de superposition de couches que celles-ci utiliseront bien le même crs en spécifiant le datum.  `coord_sf()` permet également de *zoomer* sur la carte en spécifiant les bornes x et y de la carte, ou également de définir les labels des axes.

Le premier exemple que nous allons pouvoir voir, c'est une carte choroplèthe.

Pour cela, préalablement, nous allons intégrer à nos données un fond de carte : le *spatial dataframe* `World` présent dans le package `tmap`

```{r echo=T,eval=T,warning = F}
data("World")

sdg_indicators_sf <- World %>%
  left_join(sdg_indicators)
```

```{r, echo=T,eval=T,warning = F, fig.height=5,fig.width=12}
map_sdg_indicators <- sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  ggplot() +
  geom_sf(aes(fill = log(sh_sta_mmr)),color="white",size=.2)+
  scale_fill_viridis_c()+
  theme_minimal()+
  theme(panel.background = element_rect(fill = "light blue"))
map_sdg_indicators
```

On peut exploiter de la même façon les différentes fonctions vues précédement. Par exemple avec un peu de thème et de facet.

```{r,warning= F,, fig.height=12,fig.width=14}
sdg_indicators_sf %>% 
  filter(timeperiod %in% c("2000","2005","2010","2015")) %>% 
           ggplot() +
           geom_sf(aes(fill = log(sh_sta_mmr)),color="white",size=.2)+
           scale_fill_viridis_c(
             option = "magma",
             direction = 1,
             breaks = c(0, 1, 2, 3, 4, 5, 6, 7))+
           guides(
             colour = F,
             order = 0,
             fill = guide_legend(
               direction = "horizontal",
               keyheight = unit(2, units = "mm"),
               keywidth = unit(20, units = "mm"),
               order = 1,
               title.position = "top",
               title.hjust = 0.5,
               nrow = 1,
               label.position = "bottom",
               label.hjust = 1
             )
           ) +
           theme_minimal()+
           theme(legend.position = "bottom",
                 panel.background = element_rect(fill = "light blue"))+
           labs(fill = "Taux de mortalité infantile (échelle logarithmique)") +
           facet_wrap(~timeperiod, drop = T)

```


### Les cartes à ronds proportionnels

ggplot ne peut attribuer par défaut un rond proportionnel à un polygone.

Pour travailler sur des ronds proportionnels, il faut d'abord créer le centroid de nos zones et ensuite tracer un rond proportionnel avec `geom_sf()`.

```{r, echo=T,eval=T,warning= F, fig.height=5,fig.width=12}
World_centroid <- st_centroid(World, of_largest_polygon = T)
sdg_indicators_sf_centroid <- World_centroid %>%
  left_join(sdg_indicators)

map_sdg_indicators_centroid <- sdg_indicators_sf_centroid %>% 
  filter(timeperiod == "2015",!is.na(sh_sta_mmr)) %>% 
  ggplot() +
  geom_sf(data = World, fill = "white") +
  geom_sf(aes(color = sh_sta_mmr, size = sh_sta_mmr))+
  theme_minimal()+
  theme(panel.background = element_rect(fill = "light blue"))

map_sdg_indicators_centroid
```

### Ajouter une barre d'échelle et la flèche du nord

Le package `ggspatial` permet d'enrichir simplement nos cartes `ggplot2` avec une barre d'échelle et la flèche du nord.

Les deux fonctions qui permettent cela sont `annotation_scale()` et `annotation_north_arrow()`.

L'utilisation de ces fonctions nécessitent un système de coordonnées géographiques.

```{r,message =F,warning=F, fig.height=5,fig.width=12}
sdg_indicators_sf %>%
  filter(timeperiod == "2015") %>%
  st_transform(crs = 4326) %>%
  ggplot() +
  geom_sf(aes(fill = log(sh_sta_mmr)), color = "white", size = .2) +
  coord_sf(crs = 4326) +
  scale_fill_viridis_c() +
  theme_minimal() +
  theme(panel.background = element_rect(fill = "light blue")) +
  annotation_scale(location = "br", line_width = .5) +
  annotation_north_arrow(location = "bl", height = unit(0.7, "cm"), width = unit(0.7, "cm"))
```

### Mettre plusieurs cartes côte à côte

On peut a partir d'une même carte vouloir réaliser un zoom sur une sous partie de celle-ci.
`coord_sf()` va nous permettre de *zoomer* sur une carte, et `cow_plot()` va nous permettre d'afficher nos deux cartes côte à côte.

Pour zoomer sur une carte,`coord_sf()` va avoir besoin des coordonnées *x* et *y* du cadre sur lequel on veut zoomer.
Le plus simple pour cela est de filtrer préalablement 
notre spatial dataframe et de récupérer la bbox de celle-ci.

Filtrons par exemple sur le continent africain.

```{r}
bbox_africa <- World %>% 
  filter(continent=="Africa") %>% 
  st_bbox()
```

On peut ensuite réaliser une carte zoomée sur l'Afrique.

```{r, fig.height=5,fig.width=12}
map_sdg_indicators_africa <- sdg_indicators_sf %>%
  filter(timeperiod == "2015") %>%
  ggplot() +
  geom_sf(aes(fill = log(sh_sta_mmr)), color = "white", size = .2) +
  coord_sf(xlim = c(bbox_africa[1],bbox_africa[3]),
           ylim = c(bbox_africa[2],bbox_africa[4])
           ) +
  scale_fill_viridis_c() +
  theme_minimal() +
  theme(legend.position = "right", panel.background = element_rect(fill = "light blue"))
```

On peut utiliser ensuite `plot_grid()` pour afficher nos cartes côte à côte. Il faut jouer sur les largeurs relatives pour que les deux cartes s'agencent bien.

```{r, fig.height=6,fig.width=12}
map_sdg_indicators_compo <- map_sdg_indicators +
  theme_void()+
  theme(panel.background = element_rect(fill = "light blue"),legend.position = "none")
plot_grid(map_sdg_indicators_compo,map_sdg_indicators_africa,rel_widths = c(1.7, 1))
```


<!--chapter:end:12-creer-des-cartes-avec-ggplot2.Rmd-->

# Créer des cartes avec tmap

```{r,echo=F,eval=T}
tmap_mode("plot")
```

`tmap` est un package dédié à la réalisation de cartes sous R.

La syntaxe est très proche de `ggplot`, avec l'opérateur `+` pour enchainer les options. 

L'équivalent des `geom_xx()` dans `tmap` sont les fonctions suivantes : 

- `tm_lines()` : afficher des lignes
- `tm_polygons()` : afficher des polygones
- `tm_raster()` : afficher un raster
- `tm_bubbles()` : afficher des ronds proportionnels
- `tm_markers()` : afficher des marqueurs
- `tm_text()` : afficher du texte


Les différences avec `ggplot2` :

- Les variables s'appellent dans des cotes `""` ;
- Le facetting peut se faire sur un format de données large (une carte par colonne et non une carte par modalité d'une variable) ;
- Les fonctions `tm_xx()`  incluent la définition des *classes* (nombre de classe, définition des classes et des palettes) sans passer par une fonction `scale()`  dont l'équivalent n'existe pas.

La mise en page se définit avec la fonction `tm_layout()`, la légende avec `tm_legend()`

Dans ce chapitre nous allons utiliser les packages suivants

```{r}
library(tmap)
library(sf)
library(tidyverse)
#remotes::install_github("MaelTheuliere/variousdata")
library(variousdata)
```

## tm_shape

Pour charger une donnée géométrique, il faut utiliser la fonction `tm_shape()`. `tm_shape()` permet de fixer plusieurs options de base de notre carte : la projection, la bbox, un facteur de simplification...

```{r,eval=T,echo=T}
wgs_84 <- tm_shape(World, projection = "longlat") + 
    tm_polygons() + 
tm_layout("Le monde en projection WGS84", inner.margins=c(0,0,.1,0), title.size=.8)

robin <- tm_shape(World, projection = "robin") + 
    tm_polygons() +
tm_layout(
"Le monde en project Winkel-Tripel",
    inner.margins=c(0,0,.1,0), title.size=.8)
```

```{r,echo = F,eval=T}
tmap_arrange(wgs_84,robin)
```

## Exemple de carte choroplèthe

La fonction `tm_polygons()` permet de faire des cartes choroplèthe.

```{r, echo=T,eval=T,fig.height=5,fig.width=12}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr",textNA="Valeur manquante")+
  tm_borders("white", lwd = .5)
```


## Exemple de carte à ronds proportionnels

La fonction `tm_bubble()` permet de faire des cartes à ronds proportionnels. L'utilisation de `tm_polygons()` permet sans lui spécifier de paramètre d'afficher les frontière des pays avec une couleur de remplissage par défaut.

```{r, echo=T,eval=T,fig.height=5,fig.width=12}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons()+
  tm_bubbles(size="sh_sta_mmr",col="sh_sta_mmr",textNA = "Valeur manquante")
```

## Discretisation

Pour définir comment notre variable continue va être discrétisée, deux méthodes : 

- discrétiser à la main et indiquer les valeurs limites dans l'option `breaks` de notre `tm_xx`

- utiliser l'option `style` des `tm_xx` qui permettent de choisir un algorithme de discrétisation.

La méthode de jenks par exemple permet de maximiser la variance interclasse.

```{r}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr", textNA="Valeur manquante", style="jenks")
```

L'option `n=` permet d'imposer un nombre de classes à la méthode utilisée.

```{r, echo=T,eval=T,fig.height=5,fig.width=12}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr", textNA = "Valeur manquante", style = "jenks",n = 3)
```

## Exemples de cartes avec facet

`tm_facets()` permet de réaliser des cartes à facette avec la même logique que celle de `ggplot2`.

```{r, echo=T,eval=T,fig.height=6,fig.width=12}
sdg_indicators_sf %>%
  filter(timeperiod %in% c("2000", "2005", "2010", "2015")) %>%
  tm_shape() +
  tm_polygons("sh_sta_mmr", textNA = "Valeur manquante", style = "jenks") +
  tm_facets("timeperiod")
```



## gestion des palettes

La fonction `tmaptools::palette_explorer()` permet d'accéder à une interface très simple de définition d'une palette de couleur à partir des palette *brewer*.

```{r, echo=T,eval=T,fig.height=5,fig.width=8}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr", textNA = "Valeur manquante", style = "jenks",palette = get_brewer_pal("OrRd", n = 5, contrast = c(0.2, 1)), plot = F)
```

On peut également utiliser n'importe qu'elle palette, par exemple la pelette viridis, mais sans l'interface proposée par `palette_explorer()` : 

```{r, echo=T,eval=T,fig.height=5,fig.width=8}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr", textNA = "Valeur manquante", style = "jenks",palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"))
```

## La mise en page

`tm_layout()` permet de controler les polices, la légende, les marges, les couleurs.
l'option `design.mode=T` permet de voir visuellement les marges,la position de la légende.
Le titre de la légende ne se définit pas dans `tm_layout()` mais dans `tm_polygons()`. 

L'option `title` de ces fonctions est l'équivalent d'un libellé de la variable mise dans l'aesthetic.

On peut rajouter une barre d'échelle et la flèche du nord avec `tm_scale_bar()` et `tm_compass()`.

```{r, echo=T,eval=T,fig.height=5,fig.width=8}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr",textNA = "Valeur manquante", style = "jenks",palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"),
              title = "Taux de mortalité de la mère \n(pour 100 000 naissances)")+
  tm_layout(main.title = "Taux de mortalité de la mère \n(pour 100 000 naissances) dans le monde",
            main.title.size = 1.2,
            bg.color = "skyblue",
            legend.position = c("left","bottom"),
            legend.bg.color = "white",
            legend.bg.alpha = .4,
            legend.outside = F,
            main.title.position = "center",
            frame = FALSE)+
  tm_scale_bar(position = c("center","bottom"))+
  tm_compass(position = c("right","top"))
```

Avec les cartes en ronds proportionnels, on peut spécifier un titre pour la couleur et la taille du rond.

```{r, echo=T,eval=T,fig.height=5,fig.width=8}
sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons()+
  tm_bubbles(size="sh_sta_mmr",col="sh_sta_mmr",style="jenks",
             palette=viridis(5, alpha = 1, begin = 0, end = 1, direction = 1, option = "D"),
              title.col="",
              title.size="Taux de mortalité de la mère \n(pour 100 000 naissances)")+
  tm_layout(main.title="Taux de mortalité de la mère \n(pour 100 000 naissances) dans le monde",
            main.title.size=1.2,
            outer.margins=c(0,0,0,0),
            legend.position=c("left","bottom"),
            legend.outside = F,
            main.title.position = "center",
            inner.margins = c(0, 0, 0, 0),
            frame = FALSE)+
    tm_scale_bar(position = c("center","bottom"))+
    tm_compass(position = c("right","top"))
```

## Assembler plusieurs cartes

`tmap_arrange()` permet d'assembler plusieurs cartes ensemble. La limite de `tmap_arrange()` :  la fonction ne permet pas de fixer un vecteur de largeur différent pour les cartes. A utiliser donc sur des cas qui peuvent convenir à cette contrainte.

```{r}
tmap_sdg_indicators <- sdg_indicators_sf %>%
  filter(timeperiod == "2015") %>%
  tm_shape()+
  tm_polygons("sh_sta_mmr", style = "jenks",palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"))+
  tm_layout()

tmap_sdg_indicators_africa <- sdg_indicators_sf %>%
  filter(timeperiod == "2015") %>%
  tm_shape(bbox = bbox_africa)+
  tm_polygons("sh_sta_mmr", style = "jenks",palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"))+
  tm_layout(legend.show	= F)

tmap_arrange(tmap_sdg_indicators,tmap_sdg_indicators_africa,nrow = 1)
```


## tmap pour le web

`tmap` permet simplement de convertir une carte *image* en carte interactive. Pour cela il faut changer le mode d'affichage de la carte avec `tmap_mode()`

```{r,warning=F,message=F}
tmap_mode("view")

sdg_indicators_sf %>% 
  filter(timeperiod == "2015") %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr")+
  tm_borders("white", lwd = .5)
```

## Export d'une carte

La fonction `tmap_save()`  permet d'exporter une carte `tmap`. Suivant le `tmap_mode()` activé, l'export peut se faire en fichier image ou en fichier html.

```{r echo=T,eval=F,fig.height=5,fig.width=8}
carte <- sdg_indicators_sf %>%
  filter(timeperiod == "2015") %>%
  tm_shape() +
  tm_polygons() +
  tm_bubbles(
    size = "sh_sta_mmr", col = "sh_sta_mmr",
    palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"),
    title.col = "",
    title.size = "Taux de mortalité de la mère \n(pour 100 000 naissances)"
  ) +
  tm_layout(
    main.title = "Taux de mortalité de la mère \n(pour 100 000 naissances) dans le monde",
    main.title.size = 1.2,
    outer.margins = c(0, 0, 0, 0),
    legend.position = c("left", "bottom"),
    legend.outside = F,
    main.title.position = "center",
    inner.margins = c(0, 0, 0, 0)
  )

tmap_mode("plot")
tmap_save(carte, filename = "Taux de mortalité de la mère dans le monde.png")

tmap_mode("view")
tmap_save(carte, filename = "Taux de mortalité de la mère dans le monde.html")```
```


```{r,eval=T,echo=FALSE,message = F}
tmap_mode("plot")
```


<!--chapter:end:13-creer-des-cartes-avec-tmap.Rmd-->

# Créer des cartogrammes

Un cartogramme est une carte pour laquelle une variable continue, remplace la surface des territoires représentés. La géométrie de l'espace de la carte est déformée afin de se conformer aux informations relatives à cette variable.

Les fonctions du package `cartogramm` permettent de réaliser l'opération de déformation attendue. La sortie de ces fonctions est un *spatial dataframe* avec une nouvelle géométrie. On peut ensuite utiliser cette nouvelle géométrie pour la visualiser avec tout package de cartographie.

Dans ce chapitre nous allons utiliser les packages suivants.

```{r}
library(cartogram)
library(tmap)
library(ggplot2)
#remotes::install_github("MaelTheuliere/variousdata")
library(variousdata)
data("World")
```

## Cartogramme d'aire contigue

Définition de la couche à partir de la variable d'une table. Ici en l'occurence le taux de mortalité de la mère à la naissance.

La fonction `cartogram_cont()` permet de définir la déformation attendue.

```{r, message = F,warning = F}
mmr_cont <- cartogram_cont(sdg_indicators_sf %>% 
                 filter(timeperiod == "2015"),
               "sh_sta_mmr")
```

On peut ensuite utiliser le package que l'on souhaite pour cartographier cette couche.

- avec `tmap`

```{r}
mmr_cont %>% 
  tm_shape()+
  tm_polygons("sh_sta_mmr",palette=viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"),
              title="Taux de mortalité de la mère \n(pour 100 000 naissances)")+
  tm_layout(main.title="Taux de mortalité de la mère \n(pour 100 000 naissances) dans le monde",
            main.title.size=1.2,
            bg.color = "skyblue",
            legend.position=c("left","bottom"),
            legend.outside = F,
            main.title.position = "center",
            frame = FALSE)
```

- avec `ggplot2`

```{r}
mmr_cont %>% 
  ggplot() +
  geom_sf(aes(fill = log(sh_sta_mmr)),color="white",size=.2)+
  scale_fill_viridis_c(
    option = "magma",
    direction = 1,
    breaks = c(0, 1, 2, 3, 4, 5, 6, 7))+
  guides(
    colour = F,
    order = 0,
    fill = guide_legend(
      direction = "horizontal",
      keyheight = unit(2, units = "mm"),
      keywidth = unit(20, units = "mm"),
      order = 1,
      title.position = "top",
      title.hjust = 0.5,
      nrow = 1,
      label.position = "bottom",
      label.hjust = 1
    )
  ) +
  theme_minimal()+
  theme(legend.position = "bottom",
        panel.background = element_rect(fill = "light blue"))+
  labs(fill = "Taux de mortalité infantile (échelle logarithmique)")

```

## Cartogramme d'aire non contigue

La fonction `cartogram_ncont()` permet de définir la déformation attendue.

On va ici réaliser le cartogramme sur le log de la mortalité des mères à la naissance.

```{r, message = F,warning = F}
mmr_ncont <- cartogram_ncont(sdg_indicators_sf %>% 
                               filter(timeperiod == "2015",continent == "Africa") %>% 
                               mutate(log_sh_sta_mmr = log(sh_sta_mmr)),
                             "log_sh_sta_mmr")
```


```{r, message = F,warning = F}
tm_shape(World)+
  tm_polygons()+
  tm_shape(mmr_ncont, is.master = T)+
  tm_polygons("log_sh_sta_mmr",palette=viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = "D"),
              title="Taux de mortalité de la mère \n(pour 100 000 naissances) en Afrique \néchelle logarithmique")+
  tm_layout(main.title="Taux de mortalité de la mère \n en Afrique",
            main.title.size=1,
            bg.color = "skyblue",
            legend.position=c("left","bottom"),
            legend.outside = T,
            main.title.position = "center",
            frame = F)

```

## Cartogramme de Dorling

Le cartogramme de Dorling est une représentation spatiale qui vise à remplaer les polygones par des cercles proportionnels à une variable données respectant au maximum la position spatiale des polygones.

La fonction `cartogram_dorling()` permet de définir la géométrie attendue.

On va ici réaliser un cartogramme de dorling sur le PIB par habitant en 2015.

```{r}
gdp_dorling <- cartogram_dorling(sdg_indicators_sf %>% 
                                   filter(timeperiod == "2015",!is.na(gdp_per_cap)),"gdp_per_cap")

```


```{r}
tm_shape(World) + 
  tm_borders() +
  tm_shape(gdp_dorling) + 
  tm_polygons("continent") +
  tm_layout(frame = FALSE) +
  tm_layout(main.title="PIB par habitant dans le monde",
            main.title.size=1,
            bg.color = "skyblue",
            legend.position=c("left","bottom"),
            legend.outside = F,
            main.title.position = "center",
            frame = T)
```


<!--chapter:end:14-cartogramm.Rmd-->

# Créer des cartes pour le web

## Les cartes Leaflet

[`leaflet`](https://leafletjs.com/) est une bibliothèque javascript de cartographie en ligne. R permet de produire des cartes en exploitant cette bibliothèque.

La limitation de `leaflet` est qu'il ne permet de visualiser que des données en projection WGS84.

Dans ce chapitre, nous utiliserons les packages suivants
```{r}
library(leaflet)
library(sf)
library(tidyverse)
#remotes::install_github("MaelTheuliere/variousdata")
library(variousdata)
```

### Carte choroplète

Ci-dessous un exemple avancé de carte choroplète avec leaflet.

- Définition des données de départ

```{r}
sdg_indicators_2015_sf <- sdg_indicators_sf %>% 
  filter(timeperiod ==2015)
```

- Transformation de la projection car `leaflet` ne connait que le WGS 84

```{r}
sdg_indicators_2015_sf<-st_transform(sdg_indicators_2015_sf,crs=("+proj=longlat +datum=WGS84 +no_defs"))
```

- Discrétisation de la variable d'intérêt

```{r}
bins <-quantile(sdg_indicators_2015_sf$sh_sta_mmr,
                na.rm=T)
```

- Création d'une palette de couleurs associée

`leaflet` intègre une fonction `colorBin()` qui permet d'associer à un vecteur de valeurs numériques un vecteur de couleurs en fonction d'une palette et d'un vecteur de bornes.

```{r}
pal <- colorBin("YlOrRd", domain = 
                  sdg_indicators_2015_sf$sh_sta_mmr,
                bins = bins)
```

- Création d'un label ad-hoc à afficher en surbrillance au passage de la souris sur la carte.

```{r}
labels <- sprintf(
  "<strong>%s</strong><br/>%g décès pour 100 000 naissance en 2015",
  sdg_indicators_2015_sf$geoareaname, sdg_indicators_2015_sf$sh_sta_mmr
) %>% lapply(htmltools::HTML)
```

- Réalisation de la carte

La fonction `addPolygons()` permet de créer la carte choroplète.

La fonction `addProviderTiles()` permet de rajouter un fond cartographique parmis les couches fournies par `leaflet`.

```{r,fig.width=7,fig.height=4}
leaflet(sdg_indicators_2015_sf) %>%
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data=sdg_indicators_2015_sf,
              fillColor=~pal(sh_sta_mmr),
              weight = 2,
              opacity = 1,
              color = "white",
              dashArray = "3",
              fillOpacity = 0.7,
              highlight = highlightOptions(
                weight = 5,
                color = "#666",
                dashArray = "",
                fillOpacity = 0.7,
                bringToFront = TRUE),
              label = labels,
              labelOptions = labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "15px",
                direction = "auto"))
```

### Carte à ronds proportionnels

Pour réaliser des ronds proportionnels, il va falloir comme pour `ggplot2` partir des centroides de nos polygones.

- Création de la table en entrée 

```{r}
sdg_indicators_2015_sf_centroid <- sdg_indicators_sf_centroid %>% 
  filter(timeperiod ==2015)
```

- Transformation de la projection car `leaflet` ne connait que le WGS 84

```{r}
sdg_indicators_2015_sf_centroid <- st_transform(sdg_indicators_2015_sf_centroid,crs=("+proj=longlat +datum=WGS84 +no_defs"))
```

- Discrétisation de la variable d'intérêt


```{r}
bins <-quantile(sdg_indicators_2015_sf_centroid$sh_sta_mmr,na.rm=T)
```

- Création d'une palette de couleurs associée

```{r}
pal <- colorBin("YlOrRd", domain = sdg_indicators_2015_sf_centroid$sh_sta_mmr, bins = bins)
```

- Création d'un label ad-hoc à afficher en surbrillance au passage de la souris sur la carte.

```{r}
labels <- sprintf(
  "<strong>%s</strong><br/>%g décès pour 100 000 naissance en 2015",
  sdg_indicators_2015_sf_centroid$geoareaname, sdg_indicators_2015_sf_centroid$sh_sta_mmr
) %>% lapply(htmltools::HTML)
```

- Création de la carte

```{r,fig.width=7,fig.height=4}
carte_rond_proportionnel<-leaflet(sdg_indicators_2015_sf_centroid) %>%
  addProviderTiles(providers$CartoDB.Positron) %>% 
  addPolygons(data=sdg_indicators_2015_sf,
              fillColor = "#ffffff",
              opacity=.2,
              color = "white",
              dashArray = "3",
              fillOpacity = 0.7
  ) %>% 
  addCircles(data=sdg_indicators_2015_sf_centroid,
             fillColor=~pal(sh_sta_mmr),
             radius=~100000*log2(sh_sta_mmr),
             weight = 2,
             opacity = 1,
             color = "white",
             dashArray = "3",
             fillOpacity = 0.7,
             highlight = highlightOptions(
               weight = 5,
               color = "#666",
               dashArray = "",
               fillOpacity = 0.7,
               bringToFront = TRUE),
             label = labels,
             labelOptions = labelOptions(
               style = list("font-weight" = "normal", padding = "3px 8px"),
               textsize = "15px",
               direction = "auto")) %>% 
  addLegend("bottomright", pal = pal, values = ~sh_sta_mmr,
            title = "Taux de décès des mères à la naissance",
            opacity = 1)
carte_rond_proportionnel
```

## Exporter une sortie html

La foncion `saveWidget()` permet d'exporter une sortie d'un `HTML Widget` en fichier HTML.

```{r, eval=F}
saveWidget(widget=carte_rond_proportionnel,file="Taux de décès des mères à la naissance.html")
```

<!--chapter:end:15-creer-des-graphiques-et-cartes-pour-le-web.Rmd-->

# (PART) A propos {-}

# A propos de ce document {-}

## Code source {-}

Le code source de ce document se trouve à l'adresse suivante : https://github.com/MTES-MCT/parcours_r_module_analyse_spatiale

Il est généré par l’excellente extension [bookdown](https://bookdown.org/yihui/bookdown/) de [Yihui Xie](https://yihui.name/en/).

## Inspiration {-}

Ce document est largement inspiré des deux supports suivant : 

- [Geocomputation with R](https://geocompr.robinlovelace.net/) de Robin Lovelace, Jakub Nowosad et Jannes Muenchow ;

- le contenu du module [Datavisualisation : produire des graphiques, des cartes et des tableaux avec R](https://rawgit.com/MTES-MCT/parcours-r/master/Supports_formations/m5_valorisation_des_donnees/_book/index.html), de Murielle Lethrones et Maël THEULIERE, du parcours de formation à R du Ministère de la Transition écologique et solidaire et du Ministère de la Cohésion des territoires et des Relations avec les collectivités territoriales pour la partie rappel sur les dataviz et la réalisation de cartes.

## Licence {-}

Ce document est mise à disposition selon les termes de la [Licence Ouverte2.0](https://www.etalab.gouv.fr/wp-content/uploads/2017/04/ETALAB-Licence-Ouverte-v2.0.pdf).

<center>
<a rel="license" href="https://www.etalab.gouv.fr/licence-ouverte-open-licence"><img alt="Licence Ouverte" style="border-width:0" src="https://www.etalab.gouv.fr/wp-content/uploads/2011/10/licence-ouverte-open-licence.gif" /></a><br />
</center>



## Session info {-}


```{r,echo = F}
devtools::session_info()$platform

package <- devtools::session_info()$packages %>% as_tibble() %>% 
  filter(attached == T,is_base == F,package != "COGiter") %>% 
  select(package,ondiskversion,source)
knitr::kable(package) %>% kableExtra::kable_styling()
```


<!--chapter:end:16-a-propos.Rmd-->

