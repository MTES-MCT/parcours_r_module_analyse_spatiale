---
title: "Intitulé et correction des exercices"
author: "Maël THEULIERE"
date: "15/07/2019"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

# Exercice 1 - manipuler des objets sf

-   Créer un objet des points de p qui intersectent le polygone a.

```{r exo1-consigne, include=TRUE}
library(sf)
# polygone (a - orange)
a_poly <- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a <- st_sfc(a_poly)

# lignes (l - bleues)
l1 <- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1))))
l2 <- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0))))
l <- st_sfc(l1, l2)

# multi-points (p - noirs)
p_matrix <- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2)
p_multi <- st_multipoint(x = p_matrix)
p <- st_cast(st_sfc(p_multi), "POINT")
```

```{r exo1-solution}
# solution st_filter
st_sf(p) %>% 
  st_filter(a)

# solution tidyverse
st_sf(p) %>% 
  filter(st_intersects(., a, sparse = FALSE))

# solution crochets
st_sf(p)[a, , op = st_intersects]

```

# Exercice 2 : exploitation des données DVF en API

Le but de cet exercice va être d'exploiter les données *DVF* sur les transactions immobilières dans l'ancien et la carte des quartiers de Nantes pour obtenir des indicateurs des transactions par quartier. On va utiliser pour DVF l'API mise en place par Christian Quest : <http://api.cquest.org/dvf>

```{r lecture donnees ex 2 dvf}
## Activation des packages
library(httr)
library(jsonlite)
library(sf)
library(tidyverse)

get_dvf <- GET("http://api.cquest.org/dvf?code_commune=44109")
dvf_content <- content(get_dvf, "text", encoding = "UTF-8")

dvf_json <- fromJSON(dvf_content)$resultats %>%
  # On ne garde que les données avec une géolocalisation valide, un prix et une surface renseignés.
  filter(!is.na(lon), !is.na(lat), !is.na(valeur_fonciere), !is.na(surface_relle_bati))

dvf <- st_as_sf(dvf_json, coords = c("lon", "lat"), crs = 4326)
```

-   Contour des quartiers de Nantes, ils proviennent de Nantes Métropole Open Data : <https://data.nantesmetropole.fr>

```{r lecture donnees ex 2 quartiers}
quartier_nantes <- st_read("https://data.nantesmetropole.fr/explore/dataset/244400404_quartiers-communes-nantes-metropole/download/?format=geojson&disjunctive.libcom=true&refine.libcom=Nantes&timezone=Europe/Berlin&lang=fr")
```

On veut produire les infos suivantes par quartier et année :  

- Volume de ventes (nb)  
- Pourcentage de maisons dans les ventes  
- Prix moyen au m2 par type de bien  

## Datapréparation

### Jointure spatiale pour récupérer les ventes par quartiers

```{r}
dvf_avec_quartier <- st_join(dvf, quartier_nantes %>% select(nom)) %>%
  rename(quartier = nom)
```

### Calculs

Calcul par quartier et année de la transaction du nombre de ventes, de leur montant et surface total par type de bien et tout bien confondu

```{r}
library(lubridate)

dvf_filtre <- dvf_avec_quartier %>%
  st_drop_geometry() %>%
  filter(
    nature_mutation == "Vente",
    type_local %in% c("Appartement", "Maison")
  ) %>%
  mutate(
    date_mutation = ymd(date_mutation),
    annee_mutation = year(date_mutation),
    nb_ventes = 1
  ) 

stat1 <- dvf_filtre %>%
  group_by(quartier, type_local, annee_mutation) %>%
  summarise(across(c(nb_ventes, valeur_fonciere, surface_relle_bati), sum, na.rm = TRUE), .groups = "drop")

stat2 <- dvf_filtre %>%
  group_by(quartier, annee_mutation) %>%
  summarise(across(c(nb_ventes, valeur_fonciere, surface_relle_bati), sum, na.rm = TRUE), .groups = "drop") %>% 
  mutate(type_local = "Ensemble") 


stat <- bind_rows(stat1, stat2)
```

Calcul des indicateurs demandés

```{r}
# Volume des ventes
indicateurs1 <- stat %>%
  filter(type_local == "Ensemble") %>%
  select(quartier, annee_mutation, nb_ventes)

# Pourcentage de maison dans les ventes
indicateurs2 <- stat %>%
  select(quartier, annee_mutation, type_local, nb_ventes) %>%
  pivot_wider(names_from = type_local, values_from = nb_ventes, values_fill = 0) %>%
  mutate(pourcentage_maison = 100 * Maison / Ensemble) %>%
  select(quartier, annee_mutation, pourcentage_maison)

indicateurs3 <- stat %>%
  select(quartier, annee_mutation, type_local, valeur_fonciere, surface_relle_bati) %>%
  mutate(prix_m2 = valeur_fonciere / surface_relle_bati) %>%
  select(quartier, annee_mutation, type_local, prix_m2) %>%
  pivot_wider(names_from = type_local, values_from = prix_m2) %>%
  rename_with(.cols = c(Appartement, Maison, Ensemble), .fn = ~paste0("prix_m2_", tolower(.x)))

indicateurs <- reduce(list(indicateurs1, indicateurs2, indicateurs3), left_join)

indicateurs <- quartier_nantes %>%
  select(quartier = nom) %>%
  left_join(indicateurs)
```

# Exercice 3 ggplot chap 10 : Visualisation des données DVF en API

Avec les résultats de l'exercice 2, produire les cartes du nombre de ventes et du prix au m2 des maisons en 2019 par quartier de Nantes.

```{r}
library(gouvdown)

ggplot() +
  geom_sf(
    data = indicateurs %>%
      filter(annee_mutation == 2019),
    aes(fill = nb_ventes)
  ) + 
  theme_gouv_map() +
  scale_fill_gouv_continuous()

ggplot() +
  geom_sf(
    data = indicateurs %>%
      filter(annee_mutation == 2019),
    aes(fill = prix_m2_maison)
  ) + 
  theme_gouv_map() +
  scale_fill_gouv_continuous()
```

# Exercice 4 : Assemblage de cartes sur dvf

A partir des données dvf 2014 et 2017 de la région Pays de la Loire contenues dans le package `{variousdata}` et les fonds de carte de `{COGiter}`, produire :

- une carte régionale à l'EPCI comprenant :  
  - un dégrade de couleur sur l'évolution des prix au m2 des maisons entre 2014 et 2017,  
  - un rond sur le volume des prix au m2 des maisons,  
- un zoom sur les communes des principaux EPCI, c'est à dire une carte à la commune par EPCI de type Métropole (ME) ou Communauté urbaine (CU).  

Puis, assembler ces différentes cartes sur un même graphique.

## Activation des packages

```{r}
library(variousdata) 
library(cowplot)
library(stringr)
library(COGiter)
library(gouvdown)
```

## Préparation des données

### Fonds de carte

```{r}
epci_geo_r52 <- epci_geo %>%
  left_join(epci, by = "EPCI") %>% 
  filter(grepl("52", REGIONS_DE_L_EPCI))

epci_ppaux_r52 <- filter(epci_geo_r52, NATURE_EPCI %in% c('ME', "CU")) %>% 
  pull(EPCI)

# communes des EPCI principaux 
com_epci_ppaux_r52 <- communes_geo %>% 
  left_join(communes, by = "DEPCOM") %>% 
  filter(EPCI %in% epci_ppaux_r52)

```

### dvf

```{r}
data("dvf_r52")
dvf_r52 <- dvf_r52 %>% 
  select(-c(NOM_DEPCOM:NOM_REG)) %>% 
  passer_au_cog_a_jour(code_commune = DEPCOM, garder_info_supra = TRUE, aggrege = FALSE)
```

On ne conserve que les données valides de ventes de maisons, et on les tronque, en filtrant les données à 98% pour lisser les moyennes

```{r}
dvf_r52_maisons <- dvf_r52 %>%
  filter(nature_mutation == "Vente", type_local == "Maison") %>%
  filter(!is.na(valeur_fonciere), !is.na(surface_reelle_bati)) %>%
  mutate(prix_m2 = valeur_fonciere / surface_reelle_bati) %>%
  arrange(prix_m2) %>%
  filter(between(row_number(), n() * .01, n() * .99)) %>%
  select(-prix_m2)
```

### Calcul de l'évolution des prix et du nombre de ventes

#### A l'EPCI

```{r}
prix_m2_maisons_epci <- dvf_r52_maisons %>%
  select(EPCI, NOM_EPCI, date_mutation, valeur_fonciere, surface_reelle_bati) %>%
  mutate(
    n = 1,
    annee = year(date_mutation)
  ) %>%
  select(-date_mutation) %>%
  group_by(EPCI, NOM_EPCI, annee) %>%
  summarise(across(everything(), sum), .groups = "drop") %>%
  group_by(EPCI, NOM_EPCI) %>%
  mutate(
    prix_m2 = valeur_fonciere / surface_reelle_bati,
    evo_prix_m2 = 100 * prix_m2 / lag(prix_m2) - 100
  ) %>%
  filter(annee == 2017) %>%
  ungroup()
```

#### A la commune

```{r}
prix_m2_maisons_com <- dvf_r52_maisons %>%
  select(EPCI, DEPCOM, date_mutation, valeur_fonciere, surface_reelle_bati) %>%
  mutate(
    n = 1,
    annee = year(date_mutation)
  ) %>%
  select(-date_mutation) %>%
  group_by(EPCI, DEPCOM, annee) %>%
  summarise(across(everything(), sum), .groups = "drop") %>%
  group_by(EPCI, DEPCOM) %>%
  mutate(
    prix_m2 = valeur_fonciere / surface_reelle_bati,
    evo_prix_m2 = 100 * prix_m2 / lag(prix_m2) - 100
  ) %>%
  filter(annee == 2017) %>%
  ungroup()
```

#### Intégration des données aux fonds de carte

```{r}
prix_m2_maisons_epci_sf <- epci_geo_r52 %>% 
  left_join(prix_m2_maisons_epci, by = c("EPCI", "NOM_EPCI")) %>%
  mutate(n = coalesce(n, 0))

prix_m2_maisons_com_sf <- com_epci_ppaux_r52 %>% 
  left_join(prix_m2_maisons_com, by = c("DEPCOM", "EPCI")) %>%
  mutate(n = coalesce(n, 0)) %>% 
  filter()

```

## Datavisualisation

### Carte à l'EPCI de la région

```{r}
p <- ggplot(prix_m2_maisons_epci_sf) +
  geom_sf(aes(fill = evo_prix_m2)) +
  scale_fill_gouv_continuous(palette = "pal_gouv_div1") +
  stat_sf_coordinates(aes(size = n), alpha = .5) +
  theme_gouv_map(plot_title_size = 16, subtitle_size = 12, plot_margin = margin(0, 0, 0, 0), 
                 plot_title_margin = 1, caption_margin = 1, subtitle_margin = 0) +
  guides(size = "none") +
  labs(
    fill = "En %", title = "Evolution du prix des maisons neuves en euros par m2",
    subtitle = "Entre 2014 et 2017",
    caption = "source : DVF"
  )
p
```

### zoom à la commune

Création des cartes zoom EPCI avec une fonction

```{r}
creer_zoom <- function(code_epci = "244400404") {
  
  nom_epci <- filter(epci_geo_r52, EPCI == code_epci) %>% 
    pull(NOM_EPCI) %>% 
    str_wrap(20)
  
  prix_m2_maisons_com_sf %>% 
    filter(EPCI == code_epci) %>% 
    ggplot() +
    geom_sf(aes(fill = evo_prix_m2)) +
    scale_fill_gouv_continuous(palette = "pal_gouv_div1") +
    stat_sf_coordinates(aes(size = n), alpha = .5) +
    theme_gouv_map(plot_title_size = 11, plot_margin = margin(0, 0, 0, 0), plot_title_margin = 1, caption_margin = 1, subtitle_margin = 0) +
    guides(size = "none", fill = "none") +
    labs(title = nom_epci)
  
  }

```

Réalisation des zooms

```{r}
zooms <- map(.x = epci_ppaux_r52, .f = creer_zoom)
zooms[[1]]
```

### Assemblage

```{r}
plot_grid(p, plot_grid(zooms[[1]], zooms[[2]], zooms[[4]], nrow = 2, ncol = 3), 
          nrow = 2)

  
```

# Exercice 5 : cartes pour le web

Adapter la carte régionale à l'EPCI de l'exercice 4, pour le web :    

- au survol d'un EPCI, afficher son nom, le prix au m2 et son évolution 2014-2017,  
- au survol du rond d'un EPCI, afficher son nom, le nb de ventes 2017.  

```{r}
library(ggiraph)
library(mapfactory)

p_web <- prix_m2_maisons_epci_sf %>% 
  mutate(
    sign_evol = if_else(evo_prix_m2 >=0, "+", ""),
    tooltip_fill = paste0(NOM_EPCI, " :\n", format_fr(x = prix_m2, dec = 0)," €/m2 en 2017\n", sign_evol,
                          format_fr(x = evo_prix_m2, pourcent = TRUE), " depuis 2014"),
    tooltip_size = paste0(NOM_EPCI, " :\n", n," ventes en 2017")
    ) %>% 
  ggplot() +
  geom_sf_interactive(aes(fill = evo_prix_m2, tooltip = tooltip_fill)) +
  scale_fill_gouv_continuous(palette = "pal_gouv_div1") +
  geom_point_interactive(stat = "sf_coordinates", aes(geometry = geometry, size = n, tooltip = tooltip_size), alpha = .5) +
  theme_gouv_map(plot_title_size = 16, subtitle_size = 12, plot_margin = margin(3, 3, 3, 3), 
                 plot_title_margin = 3, caption_margin = 2, subtitle_margin = 2) +
  guides(size = "none") +
  labs(
    fill = "En %", title = "Evolution du prix au m2 des maisons neuves",
    subtitle = "Entre 2014 et 2017",
    caption = "source : DVF"
  )

ggiraph(ggobj = p_web)

```
