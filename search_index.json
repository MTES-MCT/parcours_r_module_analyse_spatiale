[["index.html", "Analyses spatiales avec R Introduction Le parcours de formation Le groupe de référents R du pôle ministériel Objectifs de ce module", " Analyses spatiales avec R Maël THEULIERE, Jean-Daniel LOMENEDE, Juliette ENGELAERE-LEFEBVRE 26-08-2024 Introduction Crédit photographique Pascal Boulin Le parcours de formation Ce dispositif de formation vise à faire monter en compétence les agents du MTECT (Ministère de la Transition écologique et de la Cohésion des territoires) et du MTE (Ministère de la Transition énergétique) dans le domaine de la science de la donnée avec le logiciel R. Il est conçu pour être déployé à l’échelle nationale par le réseau des CVRH (Centre de Valorisation des Ressources Humaines). Le parcours proposé est structuré en modules de 2 jours chacun. Avoir suivi les deux premiers (ou disposer d’un niveau équivalent) est un pré-requis pour suivre les suivants qui sont proposés “à la carte” : Module 1 : Socle - Premier programme en R Module 2 : Socle - Préparation des données Module 3 : Statistiques descriptives Module 4 : Analyse des données multi-dimensionnelles Module 5 : Datavisualisation : Produire des graphiques, des cartes et des tableaux Module 6 : Publications reproductibles avec RMarkdown (à venir) Module 7 : Analyse spatiale Module 8 : Big data et optimisation du code (à venir) Module 9 : Applications interactives avec RShiny (à venir) La mise à disposition des supports de formation se fait par la page d’accueil du parcours de formation. Ces supports sont en licence ouverte. Si vous souhaitez accéder aux sources ou aux données mobilisées pendant les formations, vous pouvez directement les télécharger depuis le Github du pôle ministériel. Un package d’exercices, {savoirfR} rassemble toutes les données et les consignes d’exercices de ce parcours de formation (Modules 1, 2, 5 et 7 seulement pour l’instant). Pour vous tenir au courant de l’offre de formation proposée par le réseau des CVRH, consultez la plateforme OUPS (un accès intranet MTECT-MTE est nécessaire). Vous pouvez vous y abonner pour recevoir les annonces de formation qui vous intéressent. Pour échanger de l’information, discuter autour de R ou encore faire part de difficultés et trouver ensemble les solutions, il existe deux canaux d’entraide : s’inscrire en envoyant un message vide à l’adresse sympa@developpement-durable.gouv.fr ; rejoindre le salon Tchap #utilisateurs_r. Le groupe de référents R du pôle ministériel Un groupe pour structurer une offre de formations sur R Un réseau d’entraide Objectifs de ce module L’objectif de ce module est de présenter les éléments de manipulation des données spatiales à partir de R. Nous verrons ainsi : Ce que sont les données spatiales Comment lire des données spatiales ? Comment manipuler les données spatiales ? Comment visualiser les données spatiales ? Pour aller plus loin dans l’analyse spatiale des données : https://r-spatial.org/book/. "],["get-started.html", "Chapitre 1 Bien commencer 1.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. 1.2 Utilisation du package {savoirfR} 1.3 Créer votre arborescence de projet 1.4 Activer les packages nécessaires 1.5 Bien structurer ses projets data", " Chapitre 1 Bien commencer 1.1 Créer un projet sous Rstudio pour vous permettre de recenser vos travaux. Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ? Cela permet la portabilité : le répertoire de travail par défaut d’un projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de l’arborescence de votre machine. Fini les setwd(\"chemin/qui/marche/uniquement/sur/mon/poste\") ! Toujours sur la portabilité, un projet peut être utilisé avec un outil comme renv qui va vous intégrer en interne au projet l’ensemble des packages nécessaires au projet. Cela permet donc à votre collègue à qui vous passez votre projet de ne pas avoir à les installer et, surtout, si vous mettez à jour votre environnement R, votre projet restera toujours avec les versions des packages avec lesquelles vous avez fait tourner votre projet à l’époque. Cela évite d’avoir à subir les effets d’une mise à jour importante d’un package qui casserait votre code. Pour activer renv sur un projet, il faut l’installer avec install.packages(\"renv\"). Pour intialiser la sauvegarde des packages employés dans le projet, il faut utiliser renv::init() Les packages chargés dans le projet sont enregistrés dans un sous-dossier dédié. En cours de travail sur le projet, la commande renv::snapshot() permet de faire une sauvegarde, la commande renv::restore() permet de charger la dernière sauvegarde. En savoir plus sur renv Cela permet de se forcer à travailler en mode projet : on intègre à un seul endroit tout ce qui est lié à un projet : données brutes, données retravaillées, scripts, illustrations, documentations, publications… et donc y compris les packages avec renv. On peut travailler sur plusieurs projets en même temps, Rstudio ouvre autant de sessions que de projets dans ce cas. Les projets Rstudio intègrent une interface avec les outils de gestion de version Git et SVN. Cela veut dire que vous pouvez versionner votre projet et l’héberger simplement comme répertoire sur des plateformes de gestion de code telle que Github ou Gitlab. Pour créer un projet : Cliquez sur Project en haut à droite puis New Project. Cliquez sur New Directory. 1.2 Utilisation du package {savoirfR} Pour faciliter le déroulé de ce module, l’ensemble des exercices (énoncés, corrigés et données) a été intégré à un package réalisé par le groupe des référents R : {savoirfR} install.packages(&#39;remotes&#39;) remotes::install_github(&quot;MTES-MCT/savoirfR&quot;) Pour l’utiliser, il suffit de créer un nouveau projet dans un nouveau répertoire, en sélectionnant le “Project Type” Exercice Parcours R MTES-MCT. Remplissez et sélectionnez le module suivi. 1.3 Créer votre arborescence de projet Créer un répertoire /src où vous mettrez vos scripts R. Créer un répertoire /figures où vous mettrez vos illustrations issues de R. 1.4 Activer les packages nécessaires Commencez par rajouter un script dans le répertoire /src à votre projet qui commencera par : activez l’ensemble des packages nécessaires, chargez les données dont vous aurez besoin. # remotes::install_github(&quot;joelgombin/banR&quot;) library(banR) # remotes::install_github(&quot;antuki/CARTElette/CARTElette@RPackage&quot;) library(CARTElette) library(cartogram) # remotes::install_github(&quot;MaelTheuliere/COGiter&quot;) library(COGiter) library(cowplot) # remotes::install_gitlab(&#39;dreal-pdl/csd/datalibaba&#39;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) library(datalibaba) library(DT) library(ggiraph) library(ggspatial) library(glue) # remotes::install_github(&quot;spyrales/gouvdown&quot;) library(gouvdown) # remotes::install_github(&quot;spyrales/gouvdown.fonts&quot;) library(gouvdown.fonts) library(htmltools) library(htmlwidgets) library(jsonlite) library(kableExtra) library(knitr) library(leaflet) library(lubridate) # remotes::install_gitlab(&#39;dreal-pdl/csd/mapfactory&#39;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) library(mapfactory) library(mapview) library(osmdata) library(osmextract) library(osrm) library(rmapshaper) library(RPostgres) library(savoirfR) library(scales) library(sf) library(spData) library(tidyverse) # comprend ggplot2, stringr, purrr, readr, httr library(tmap) library(tmaptools) # remotes::install_github(&quot;MaelTheuliere/variousdata&quot;) library(variousdata) library(viridis) load(&quot;extdata/admin_express.RData&quot;) load(&quot;extdata/sirene.RData&quot;) prefectures &lt;- read_csv2(&quot;extdata/prefecture.csv&quot;) 1.5 Bien structurer ses projets data Plusieurs documents peuvent vous inspirer sur la structuration de vos projets data par la suite. En voici quelques uns : https://github.com/pavopax/new-project-template https://nicercode.github.io/blog/2013-04-05-projects/ https://www.inwt-statistics.com/read-blog/a-meaningful-file-structure-for-r-projects.html http://projecttemplate.net/architecture.html A partir du moment où quelques grands principes sont respectés (un répertoire pour les données brutes en lecture seule par exemple), le reste est surtout une question d’attirance plus forte pour l’une ou l’autre solution. L’important est de vous tenir ensuite à garder toujours la même structure dans vos projets afin de vous y retrouver plus simplement. "],["modelisation.html", "Chapitre 2 La modélisation des données spatiales 2.1 Les données vecteur 2.2 Les données raster 2.3 La structuration des données géographiques avec R 2.4 Format des objets spatiaux sf", " Chapitre 2 La modélisation des données spatiales Dans ce chapitre, nous allons développer une brève introduction à la modélisation des données géographiques. 2.1 Les données vecteur Les données vecteur modélisent le monde utilisant des points, des lignes et des polygones. Les données “vecteur” sont en général plus utilisées en sciences sociales, les territoires créés par l’homme ayant la plupart du temps des frontières discrètes. Derrière les données vecteur, se trouvent des points. Les points peuvent représenter des caractéristiques autonomes (comme l’emplacement de l’établissement d’une entreprise), ou peuvent être reliés entre eux pour former des géométries plus complexes telles que des lignes (comme des cours d’eau) et des polygones (les frontières d’un pays). Ces points sont localisés à travers un système de coordonnées de référence (CRS). La plupart des géométries ponctuelles ne contiennent que deux dimensions (les CRS à trois dimensions contiennent une valeur supplémentaire, z, pour la hauteur du point en référence au niveau de la mer). 2.2 Les données raster Les données raster modélisent la surface du globe à l’aide de cellules de taille identique. Les données “raster” sont en générale plus utilisées dans les science environnementales, du fait de la fiabilité des données de télédétections disponibles. 2.3 La structuration des données géographiques avec R 2.3.1 {sf} pour les données vecteur Le packages {sf} permet de gérer les données vecteur dans R. Avant {sf} existait le package {sp}, que vous pourrez rencontrer suivant les packages plus spécifiques que vous utiliserez ou en cherchant de l’aide. Les avantages de {sf} sont multiples : Standardisation : {sf} utilise le modèle de données simple feature1 qui est un standard largement utilisé dans le domaine de la géomatique. Simplification du modèle de données. Les données spatiales sont un dataframe avec une variable spécifique renseignant la géométrie. Un type ad hoc (sfc) a été créé en plus des types standard (numériques, entiers, booléens, caractères, facteurs…). Ce dataframe aura une classe spécifique qui lui sera associée (classe sf). La syntaxe des fonctions est unifiée et simplifiée selon le manifeste du tidyverse2. Intégration. Les verbes du tidyverse sont compatibles avec les données spatiales de classe sf et vont parfois agir avec des propriétés spécifiques sur les données géométriques. On peut également utiliser le pipe dans le processus de travail. Perfomance : meilleure performance dans la lecture et l’écriture des données. Voir un benchmark sur la page du package sf 2.3.2 {terra}, {raster} et {stars} pour les données raster Les packages {raster}, {terra} et {stars} permettent de gérer les données raster dans R. {raster} est, comme {sp}, un package historique amené à être supplanté par {stars} et {terra}. {stars} est d’une part plus vaste que raster, car il vise à gérer les données spatio-temporelle plus largement. {stars} est intégré à {sf} et au {tidyverse}. Le package {terra} a été publié début 2020, il propose des méthodes de traitement et d’analyse de données raster. On se limitera pour la suite du cours aux données vecteur et donc à {sf}. 2.4 Format des objets spatiaux sf Les objets sf sont des data.frame dont l’une des colonnes contient des géométries. Cette colonne est de la classe sfc (simple feature column) et chaque individu de la colonne est une sfg (simple feature geometry). Les fonctions st_point(), st_multipoint(), st_linestring(), st_polygon()… créent des objets géométriques de type sfg à partir de coordonnées structurées sous forme d’une matrice. Pour passer une liste d’objets géométriques sfg au format sf, il faut lui donner les propriétés de colonne géométrique avec st_sfc() puis les propriétés de dataframe géographique avec st_sf(). A l’inverse, la fonction st_geometry() appliquée à un objet sf renvoie la colonne géométrique seule, au format sfc. Le format sf est très pratique dans la mesure où les données et les géométries sont intrinsèquement liées dans un même objet. Pour en savoir plus : voir la vignette décrivant le format simple feature : Simple Features for R https://en.wikipedia.org/wiki/Simple_Features↩︎ https://tidyverse.tidyverse.org/articles/manifesto.html↩︎ "],["crs.html", "Chapitre 3 Les Systèmes de Coordonnées de Référence 3.1 Le système géodésique ou datum 3.2 Les coordonnées 3.3 Code EPSG", " Chapitre 3 Les Systèmes de Coordonnées de Référence Les données spatiales visent à modéliser la terre. La terre est un objet dont la mesure a une longue histoire, qu’on a pensé plate, cylindrique, ronde, ellipsoïde. Maintenant, on sait que la terre a cette forme là : THE REAL SHAPE OF PLANET EARTH - 3D Animation HD from eLearn.Punjab on Vimeo. Les systèmes de coordonnées de référence vont permettre de se repérer sur la surface de la terre. 3.1 Le système géodésique ou datum Pour modéliser la surface terrestre, on va définir un géoïde, qui est la surface théorique de la pesanteur. Ce géoïde est proche d’un ellipsoïde, c’est à dire une surface obtenue en faisant tourner une ellipse sur son axe. La terre est en effet compressée : le rayon à l’équateur est 11,5 km plus long que le rayon polaire (Maling 1992). On va donc pouvoir approximer ce géoïde par un ellipsoïde. Un point quelconque est repéré par rapport à l’ellipsoïde en utilisant un système de coordonnées sphériques : longitude, latitude, altitude. Le datum ou système géodésique va correspondre aux paramètres de forme de l’ellipsoïde et de positionnement sur celle-ci. On va distinguer deux types de datum : les datum locaux et les datum globaux. Historiquement n’existait que des datum locaux, c’est à dire qui définissait une ellipse optimale pour correspondre à une partie déterminée de la surface de la terre. Cette contrainte était liée à la façon de définir le géoïde : avant les techniques spatiales, on utilisait des mesures de triangulation à partir d’un point défini par mesure astronomique. Depuis l’avènement des techniques spatiales, on est capable de définir un datum global grâce aux mesures satellitaires. Le système mondial de référence est aujourd’hui le WGS 84, associé au GPS (code EPSG 4326). Il y a donc aujourd’hui beaucoup de datum, un pour la plupart des pays, qui maximise la modélisation de l’ellipsoïde sur leur territoire, et des datums globaux. 3.2 Les coordonnées Pour se repérer sur terre, on va utiliser un système géodésique sur lequel on va se positionner avec des coordonnées. On distingue deux types de coordonnées : 3.2.1 Coordonnées géographiques Les systèmes de coordonnées géographiques identifient tout lieux sur la surface de la terre en utilisant deux paramètres, la longitude et la lattitude : La Longitude est la localisation sur la direction Est-Ouest. Elle est définie par l’angle par rapport à un méridien. La Latitude définie la localisation sur la direction Nord-Sud. Elle est définie par l’angle avec l’équateur. Dans un système de coordonnées géographiques, les lieux sont donc identifiés par des angles et non des mètres. 3.2.2 Coordonnées en projection Les systèmes de coordonnées projetés se basent sur une modélisation de la terre plane (donc projetée sur un plan) et un système de coordonnés cartésien pour définir un point sur ce plan à partir d’une origine, d’un axe x, d’un axe y et d’une unité de mesure (comme le mètre). Tous les systèmes de coordonnées projetés se basent sur un système de coordonnées géographiques et sur une projection spatiale des données de l’ellipse en 3D sur un plan. Cet exercice ne peut se faire sans distorsion. Les propriétés de la surface de la terre comme l’aire, la direction, la distance, la forme ne peuvent être toutes conservées. En général un système de coordonnées projetés ne permet de préserver qu’une ou deux de ces propriétés. On classifie d’ailleurs ces projections selon les propriétés conservées : conformes (conservent les angles) équivalentes (conservent les surfaces) aphylactique (peut être équidistante, c’est-à-dire conserver les distances sur les méridiens) On distingue également les projection en fonction de leur mode de projection. Il y a trois principaux groupes de projections : Conique : la terre est projetée sur un cone reposant sur une ou deux tangentes. Les distorsions sont faibles sur la ligne de tangente et augmentent ensuite avec la distance à celle-ci. C’est ainsi le type de projection le mieux adapté pour des cartes réalisées sur des latitudes médianes. Cylindrique : ces projections projettent la surface de la terre sur un cylindre. Souvent utilisées pour cartographier la terre entière. Plane : projection du globe sur une surface plane tangeante en un point ou sur une ligne. Souvent utilisée pour les régions polaires. 3.2.3 Exemple de projections 3.2.3.1 Equal Earth Le but de la projection Equal-Earth est de représenter la Terre avec toutes ses régions à part égale. Equal Earth est une projection pseudo-cylindrique ressemblant à celle de Robinson qui évoque comme elle la rotondité de la Terre. Mais à la différence de cette dernière, elle préserve les surfaces. http://cartonumerique.blogspot.com/2018/11/la-projection-equal-earth.html 3.2.3.2 Lambert 93 Depuis décembre 2000, le système de projection officiel de la France métropolitaine est le Lambert 93 (code EPSG 2154). Il s’agit d’une projection conique conforme, référencée à travers le RGF93. Ce système a en commun avec le WGS84 - utilisé notamment par le système GPS de positionnement par satellite - l’ellipsoïde de référence IAG GRS80. 3.3 Code EPSG L’EPSG (European Petroleum Survey Group), un groupe créé en 1985, a défini une liste des systèmes de coordonnées géoréférencées et leur a associé des codes pour les identifier. Le groupe est devenu en 2005 le “Comité de topographie et de positionnement” de l’Association internationale des producteurs de pétrole et de gaz (OGP). La liste peut être trouvée sur ce site. Un système même géodésique peut recevoir plusieurs codes EPSG selon son utilisation : 2D ou 3D par exemple. C’est le cas du WGS84, dont le code EPSG est 4326 en 2D mais 4979 en 3D. "],["lire-des-donnees-spatiales.html", "Chapitre 4 Lire et écrire des données spatiales avec R 4.1 Lire des fichiers plats 4.2 Ecrire des fichiers plats 4.3 Lire des données spatiales du web 4.4 Lire/écrire des données spatiales sur PostGIS 4.5 Convertir un dataframe 4.6 Données contenues dans des packages", " Chapitre 4 Lire et écrire des données spatiales avec R Dans ce chapitre, nous allons utiliser les packages suivants : # CRAN library(DT) library(remotes) library(RPostgres) library(sf) library(spData) library(tidyverse) # Gitlab-forge library(datalibaba) # Github library(COGiter) library(CARTElette) Le package {sf} s’appuie sur la librairie externe GDAL (Geospatial Data Abstraction Library) pour lire et écrire les données spatiales. GDAL est une librairie permettant de lire et d’écrire des données vecteur et raster de n’importe quel format de fichier ou base de données. Les fonctions de lecture et d’écriture de {sf} s’appellent st_read() et st_write(). Pour lire des données spatiales, st_read() a besoin : d’une source de donnée : un fichier, un répertoire, une base de données ; d’un layer: une table de données spatiale spécifique du fichier, répertoire, ou de la base de données ; On peut avoir besoin de rajouter des options spécifiques au format de la source. Par exemple, sur des données en csv, il faut pouvoir spécifier la composante spatiale des données (les champs X, Y ou longitude, latitude). 4.1 Lire des fichiers plats st_read() permet de lire des données spatiales disponibles en fichier plat. Le format de fichier plat le plus populaire en géomatique est ESRI Shapefile. Ce format, en plus de ne pas être un format ouvert, a des limites bien documentées3. Avec l’avènement du web, le format GeoJSON se développe beaucoup, bien qu’il soit aussi limité. Le format considéré comme le plus prometteur est le format OGC GeoPackage promu par l’Open Geospatial Consortium4. Mais la liste des formats lisibles par {sf} est bien plus vaste. Pour l’obtenir, on peut utiliser st_drivers(), qui liste les drivers utilisables par {sf} : DT::datatable(st_drivers() %&gt;% arrange(name)) Exemple de lecture d’une donnée au format GeoPackage: les données sur la Leucémie à New York disponibles dans le package spData5. geo_fichier &lt;- system.file(&quot;shapes/NY8_bna_utm18.gpkg&quot;, package = &quot;spData&quot;) NY_leukemia &lt;- st_read(dsn = geo_fichier) 4.2 Ecrire des fichiers plats Ecrire des fichiers plats va se faire avec la fonction st_write(). st_write(obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.gpkg&quot;) Notez que si vous cherchez à exporter une nouvelle fois ce fichier, vous aurez un message d’erreur. Pour pouvoir écraser ce fichier, vous avez deux options : Utiliser le paramètre layer_option qui vous permet d’inclure des options propres au driver utilisé. st_write( obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.gpkg&quot;, append = FALSE ) Utiliser le paramètre delete_layer = TRUE de st_write() qui vous permet d’écraser les layers avant sauvegarde (paramètre qui ne dépend pas du driver utilisé). st_write( obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.gpkg&quot;, delete_layer = TRUE ) A noter que st_write() peut exporter des tables géographiques au format csv : st_write( obj = NY_leukemia, dsn = &quot;extdata/NY_leukemia.csv&quot;, layer_options = &quot;GEOMETRY=AS_XY&quot;, delete_layer = TRUE ) Il faut juste lui préciser comment on souhaite écrire la géométrie dans la table exportée, avec layer_options = \"GEOMETRY=AS_WKT\" ou layer_options = \"GEOMETRY=AS_XY\". 4.3 Lire des données spatiales du web 4.3.1 Lire des données geojson sf peut lire un geojson qu’il soit hébergé sur un serveur compréssé ou non ou encore disponible par api. 4.3.1.1 Exemple 1 (geojson classique): st_read(&quot;https://france-geojson.gregoiredavid.fr/repo/regions.geojson&quot;) %&gt;% filter(code &gt; &quot;10&quot;) %&gt;% select(code) %&gt;% plot() 4.3.1.2 Exemple 2 (api) L’api de découpage administratif permet de charger des contours administratifs. Dans l’exemple suivant, nous chargeons les contours des epci du département 44. url &lt;- &#39;https://geo.api.gouv.fr/epcis?codeDepartement=44&amp;format=geojson&amp;geometry=contour&#39; st_read(url) %&gt;% select(code) %&gt;% plot() 4.3.2 Exemple 3 (geojson compressé) sf repose sur GDAL et permet également de lire des geojsons compressés. On pourrait faire de même avec un shapefile compressé en .zip. Cela évite de télécharger le fichier et de le décompresser. Voici un exemple pour récupérer les bâtiments de la commune de Nantes provenant du PCI redistribué par Etalab. vfs &lt;- &#39;/vsigzip//vsicurl/https://cadastre.data.gouv.fr/data/etalab-cadastre/latest/geojson/communes/44/44109/cadastre-44109-batiments.json.gz&#39; batiment_nantes &lt;- st_read(dsn = vfs) Pour aller plus loin sur les Virtual File Systems : https://gdal.org/user/virtual_file_systems.html 4.3.3 Lire des données WFS sf permet aussi de lire des données WFS. crte &lt;- sf::st_read(dsn = &#39;https://datacarto.sigloire.fr/wfs?REQUEST=getCapabilities&amp;service=WFS&amp;VERSION=2.0.0&#39;, layer = &quot;ms:r_portrait_crte_r52&quot;) crte %&gt;% select(nom_territ) %&gt;% plot() On indique au niveau du paramètre dsn l’url du webservice WFS de la plateforme et au niveau du parametre layer le nom de la couche. Pour aller plus loin dans l’exploitation des flux WFS dans R : https://inbo.github.io/tutorials/tutorials/spatial_wfs_services/. 4.4 Lire/écrire des données spatiales sur PostGIS PostGIS, c’est l’extension géomatique de PostgreSQL permettant de stocker des données géo sur un serveur de données et de les manipuler. R vous permet de vous connecter simplement à une base PostGIS. Pour cela vous aurez besoin du package {DBI} (package permettant de s’interfacer à des bases de données) et du package {RPostgres} (interface à PostgreSQL en particulier). Rstudio a développé tout un site sur les interactions entre les bases de données et R, vous pouvez le trouver à l’adresse suivante : db.rstudio.com. Rstudio possède même depuis la version 1.1 un onglet de connexion vous permettant de visualiser vos connexions aux bases. Pour se connecter à une base, il faut définir un driver (à quelle type de base on veut se connecter et selon quel protocole) et un connecteur (les informations de connexion). drv &lt;- dbDriver(&quot;Postgres&quot;) con &lt;- dbConnect(drv, dbname = &quot;nom_de_ma_db&quot;, host = &quot;adresse_ip_du_serveur&quot;, port = numero_du_port, user = &quot;nom_utilisateur&quot;, password = &quot;mot_de_passe_super_secret&quot; ) Pour lire des données sur le serveur, on va utiliser encore la fonction st_read() en lui définissant 2 paramètres : le connecteur et la requête que l’on veut réaliser. ma_table &lt;- st_read(con, query = &quot;SELECT * FROM le_schema.ma_table&quot;) L’avantage ici est que vous pouvez faire travailler le serveur directement sans avoir à faire travailler votre poste de travail. Vous pouvez très bien, dans cette requête sql, réaliser quelques filtres, sélections et agrégations. Celles-ci seront alors réalisées par le serveur posgreSQL et non par votre session R qui ne récupérera que le résultat. Vous pouvez écrire vos données ensuite de la même façon avec st_write() st_write(ma_table, dsn = con, layer = Id(schema = &quot;schema&quot;, table = &quot;ma_table&quot;) ) Un package, encore expérimental, de la DREAL Pays de la Loire, {datalibaba} simplifie l’écriture des instructions de lecture/écriture de données vers ou depuis un SGBD Postgresql/postgis. Il propose de stocker vos identifiants de connexion dans vos variables d’environnement, c’est à dire en dehors de votre script, afin d’en préserver la confidentialité, mais aussi de vous éviter de les réécrire dans chaque script. L’utilisateur n’a plus à se préoccuper du driver de connexion ni de la fonction de lecture ou de comment placer le nom du schéma par rapport au nom de la table. Les types propres à R, comme les facteurs, sont préservés au ré-import. Les instruction précédentes deviennent : remotes::install_gitlab(&#39;dreal-pdl/csd/datalibaba&#39;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) library(datalibaba) poster_data(data = regions_geo, schema = &quot;admin_express&quot;, table = &quot;n_regions&quot;, pk = &#39;REG&#39;, db = &#39;referentiels&#39;) station &lt;- importer_data(table = &quot;station&quot;, schema = &quot;pesticides&quot;, base = &quot;production&quot;) Pour tester ces fonctions, le SSP Cloud permet de lancer des instances de postgresql/postgis et de les interoger depuis une session RStudio. 4.5 Convertir un dataframe Une autre façon d’obtenir un spatial dataframe est de convertir un objet existant en objet sf. Par exemple, partir d’un dataframe sur lequel on va définir à la fois la ou les colonnes contenant la dimension géographique et le crs de référence. Ou encore convertir un objet de type sp en objet de type sf. Pour cela, la fonction st_as_sf() permet de convertir un objet en objet sf en définissant la composante spatiale. La fonction st_set_crs() permet de définir le crs de notre objet. Exemple, nous allons lire les coordonnées géographiques des préfectures de région. prefectures &lt;- read_csv2(&quot;extdata/prefecture.csv&quot;) prefectures_geo &lt;- st_as_sf(prefectures, coords = c(&quot;x&quot;, &quot;y&quot;), crs = 2154) 4.6 Données contenues dans des packages Depuis le développement de {sf}, de nombreux packages proposent des données géographiques. Pour la France, les packages {CARTElette} et {COGiter} propose des fonds de cartes aux contours administratifs. Ils s’installent depuis github : remotes::install_github(&quot;MaelTheuliere/COGiter&quot;) remotes::install_github(&quot;antuki/CARTElette/CARTElette@RPackage&quot;) {CARTElette} propose de télécharger les différents fonds de plan administratifs d’admin-Express COG de l’IGN, de tous les millésimes jusque 2021. charger_carte(COG = 2021, nivsupra = &quot;REG&quot;, geometrie_simplifiee = FALSE) %&gt;% st_geometry() %&gt;% plot() Reading layer `REG_2021_CARTElette&#39; from data source `/tmp/RtmpwytDxM/REG_2021_CARTElette.shp&#39; using driver `ESRI Shapefile&#39; Simple feature collection with 18 features and 2 fields Geometry type: MULTIPOLYGON Dimension: XY Bounding box: xmin: -5.141241 ymin: 40.26843 xmax: 9.560094 ymax: 51.08899 Geodetic CRS: WGS 84 {COGiter} contient le dernier millésime des fonds de plan administratifs. Ces couches sont obtenues par simplification des couches admin-express COG de l’IGN et sont adaptées à la visualisation d’indicateurs statistiques. Il comprend pour la métropole et chaque DROM un fond de carte pour les niveaux communes, EPCI, départements, régions : ls(&quot;package:COGiter&quot;, pattern = &quot;_geo$&quot;) [1] &quot;communes_971_geo&quot; &quot;communes_972_geo&quot; &quot;communes_973_geo&quot; [4] &quot;communes_974_geo&quot; &quot;communes_976_geo&quot; &quot;communes_geo&quot; [7] &quot;communes_metro_geo&quot; &quot;departements_971_geo&quot; &quot;departements_972_geo&quot; [10] &quot;departements_973_geo&quot; &quot;departements_974_geo&quot; &quot;departements_976_geo&quot; [13] &quot;departements_geo&quot; &quot;departements_metro_geo&quot; &quot;epci_971_geo&quot; [16] &quot;epci_972_geo&quot; &quot;epci_973_geo&quot; &quot;epci_974_geo&quot; [19] &quot;epci_976_geo&quot; &quot;epci_geo&quot; &quot;epci_metro_geo&quot; [22] &quot;filtrer_cog_geo&quot; &quot;regions_971_geo&quot; &quot;regions_972_geo&quot; [25] &quot;regions_973_geo&quot; &quot;regions_974_geo&quot; &quot;regions_976_geo&quot; [28] &quot;regions_geo&quot; &quot;regions_metro_geo&quot; La fonction filtrer_cog_geo() vous permet d’obtenir une liste de spatial dataframes des différentes échelles, centrée sur une partie du territoire (que ce soit une commune, un EPCI, un département ou une région) dès lors que vous connaissez son code officiel. Exemple sur la Normandie : normandie &lt;- filtrer_cog_geo(reg = &quot;28&quot;) glimpse(normandie) List of 4 $ communes : sf [2,651 × 3] (S3: sf/tbl_df/tbl/data.frame) ..$ DEPCOM : chr [1:2651] &quot;50272&quot; &quot;76515&quot; &quot;14293&quot; &quot;27021&quot; ... ..$ AREA : num [1:2651] 17596289 3390000 6701110 8186754 5573846 ... ..$ geometry:sfc_MULTIPOLYGON of length 2651; first list element: List of 1 .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;DEPCOM&quot; &quot;AREA&quot; $ epci : sf [71 × 3] (S3: sf/tbl_df/tbl/data.frame) ..$ EPCI : Factor w/ 1256 levels &quot;200000172&quot;,&quot;200000438&quot;,..: 18 38 95 96 113 118 157 226 231 244 ... ..$ AREA : Units: [m^2] num [1:71] 5.76e+08 6.64e+08 2.82e+08 3.66e+08 5.73e+08 ... ..$ geometry:sfc_POLYGON of length 71; first list element: List of 1 .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;EPCI&quot; &quot;AREA&quot; $ departements: sf [5 × 3] (S3: sf/tbl_df/tbl/data.frame) ..$ DEP : Factor w/ 101 levels &quot;01&quot;,&quot;02&quot;,&quot;03&quot;,..: 14 26 51 62 77 ..$ AREA : Units: [m^2] num [1:5] 5.59e+09 6.04e+09 6.02e+09 6.14e+09 6.32e+09 ..$ geometry:sfc_POLYGON of length 5; first list element: List of 1 .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;DEP&quot; &quot;AREA&quot; $ regions : sf [1 × 3] (S3: sf/tbl_df/tbl/data.frame) ..$ REG : Factor w/ 18 levels &quot;01&quot;,&quot;02&quot;,&quot;03&quot;,..: 9 ..$ AREA : Units: [m^2] num 3.01e+10 ..$ geometry:sfc_POLYGON of length 1; first list element: List of 1 .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;REG&quot; &quot;AREA&quot; plot(normandie$epci) Le package COGiter propose également : les tables du COG 2022 de l’Insee, une table de passage des COG historiques vers le COG millésimé 2022, des fonctions d’aide à au passage de jeux de données vers le millésime du COG 2022, des fonctions de calculs d’agrégats aux différentes échelles territoriales, des fonctions d’aide à la sélection des différents fond de cartes nécessaire à la mise en page de cartes statistiques. Son utilisation est désormais vue lors du module 2. voir http://switchfromshapefile.org/↩︎ https://www.geopackage.org/↩︎ Issues de Waller and Gotway (2004) Applied Spatial Statistics for Public Health Data.↩︎ "],["operation-sur-donnees-attributaires.html", "Chapitre 5 Les opérations sur données attributaires", " Chapitre 5 Les opérations sur données attributaires Dans ce chapitre, nous allons utiliser les packages suivants : # CRAN library(mapview) library(sf) library(tidyverse) Nous utiliserons les contours des territoires de la France métropolitaine issus de Admin Express. load(&quot;extdata/admin_express.RData&quot;) Prenons la table des départements, cette table est un dataframe spatial. class(departements_geo) [1] &quot;sf&quot; &quot;data.frame&quot; On peut utiliser mapview() pour voir ce jeu de données. mapview(departements_geo, zcol = &quot;NOM_DEP&quot;, legend = FALSE) Comme évoqué dans la partie 1, on peut tout à fait appliquer sur un dataframe spatial les verbes du tidyverse comme sur un dataframe, notamment utiliser les verbes de dplyr. Nous pouvons à partir de cette table filtrer les départements d’une certaine région. departements_geo %&gt;% filter(INSEE_REG == 52) # A tibble: 5 × 6 ID NOM_DEP INSEE_DEP INSEE_REG AREA geometry &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; [m^2] &lt;MULTIPOLYGON [m]&gt; 1 DEP0000000000000… LOIRE-… 44 52 7.00e9 (((276339 6716135, 27628… 2 DEP0000000000000… MAINE-… 49 52 7.16e9 (((419761 6744627, 41976… 3 DEP0000000000000… MAYENNE 53 52 5.21e9 (((398109 6788330, 39810… 4 DEP0000000000000… SARTHE 72 52 6.24e9 (((463283 6791785, 46327… 5 DEP0000000000000… VENDEE 85 52 6.76e9 (((293744 6673579, 29370… Nous pouvons ne sélectionner que quelques variables departements_geo %&gt;% select(INSEE_DEP) %&gt;% glimpse() Rows: 96 Columns: 2 $ INSEE_DEP &lt;fct&gt; 01, 2B, 02, 2A, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, … $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((839096 6563..., MULTIPOLYGON ((… A noter que par défaut, un dataframe spatial gardera toujours la géométrie. On dit qu’elle est collante. Au besoin, pour la supprimer d’un jeu de donnée, il faut lui appliquer la fonction st_drop_geometry() qui ne renverra que les données attributaires. Nous pouvons agréger nos données. regions &lt;- departements_geo %&gt;% group_by(INSEE_REG) %&gt;% summarise(AREA = sum(AREA)) glimpse(regions) Rows: 13 Columns: 3 $ INSEE_REG &lt;fct&gt; 11, 24, 27, 28, 32, 44, 52, 53, 75, 76, 84, 93, 94 $ AREA [m^2] 12064378723 [m^2], 39470054055 [m^2], 47980260943 [m^2], 301… $ geometry &lt;GEOMETRY [m]&gt; POLYGON ((670084 6886723, 6..., POLYGON ((690565 6713347, 6.… On voit que summarise permet non seulement d’agréger nos données attributaires, mais également les géométries. Cette opération permet donc de retrouver directement notre carte des régions métropolitaines. mapview(regions, zcol = &quot;INSEE_REG&quot;, legend = FALSE) On peut enfin effectuer des jointures attributaires sur nos données en utilisant les verbes à deux dataframes de dplyr. Par exemple on va pouvoir récupérer, dans la table regions_geo de notre RData, les libellées de nos régions. regions &lt;- regions %&gt;% left_join(regions_geo %&gt;% st_drop_geometry(), by = c(&quot;INSEE_REG&quot;) ) Nous pouvons alors utiliser ce nouvelle attribut pour nos cartes. mapview(regions, zcol = &quot;NOM_REG&quot;, legend = FALSE) Attention, quand vous réalisez une jointure entre deux tables de données : X %&gt;% ZZ_join(Y) La composante spatiale n’est conservée que pour la première table X. "],["les-operations-sur-donnees-spatiales.html", "Chapitre 6 Les opérations spatiales sur les données 6.1 Filtrer 6.2 Prédicats spatiaux 6.3 Les jointures spatiales 6.4 Les mesures 6.5 Carroyage", " Chapitre 6 Les opérations spatiales sur les données Les opérations spatiales sont des opérations prenant nos données en entrée pour en sortir un résultat dépendant de leur composante spatiale (forme, localisation). Dans ce chapitre, nous allons utiliser les packages suivants. # CRAN library(mapview) library(sf) library(tidyverse) Nous utiliserons les données de la table des régions de la France métropolitaine et des établissements publics de coopération intercommunale (EPCI)6 de la France Métropolitaine load(&quot;extdata/admin_express.RData&quot;) glimpse(epci_geo) Rows: 1,241 Columns: 5 $ ID &lt;fct&gt; EPCI00000000000000000001, EPCI00000000000000000002, EPCI0000… $ CODE_EPCI &lt;fct&gt; 200000172, 200000438, 200000545, 200000628, 200000800, 20000… $ NOM_EPCI &lt;fct&gt; &quot;CC Faucigny-Glières&quot;, &quot;CC du Pays de Pontchâteau Saint-Gild… $ TYPE_EPCI &lt;fct&gt; CC, CC, CC, CC, CC, CC, CC, CC, CC, CC, CA, CC, CC, CC, CC, … $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((964676 6561..., MULTIPOLYGON ((… glimpse(departements_geo) Rows: 96 Columns: 6 $ ID &lt;fct&gt; DEP000000000000000000001, DEP000000000000000000002, DEP00000… $ NOM_DEP &lt;fct&gt; AIN, HAUTE-CORSE, AISNE, CORSE-DU-SUD, ALLIER, ALPES-DE-HAUT… $ INSEE_DEP &lt;fct&gt; 01, 2B, 02, 2A, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, … $ INSEE_REG &lt;fct&gt; 84, 94, 32, 94, 84, 93, 93, 93, 84, 44, 76, 44, 76, 76, 93, … $ AREA [m^2] 5774813520 [m^2], 4722274798 [m^2], 7419025664 [m^2], 403749… $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((839096 6563..., MULTIPOLYGON ((… glimpse(regions_geo) Rows: 13 Columns: 4 $ ID &lt;fct&gt; REG000000000000000000001, REG000000000000000000002, REG00000… $ NOM_REG &lt;fct&gt; AUVERGNE-RHONE-ALPES, BOURGOGNE-FRANCHE-COMTE, BRETAGNE, CEN… $ INSEE_REG &lt;fct&gt; 84, 27, 53, 24, 94, 44, 32, 11, 28, 75, 76, 52, 93 $ geometry &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((974065 6594..., MULTIPOLYGON (((880573 6730.… 6.1 Filtrer Nous souhaitons par exemple filtrer nos EPCI sur les EPCI du département de Loire-Atlantique. departement_44 &lt;- departements_geo %&gt;% filter(INSEE_DEP == &quot;44&quot;) epci_d44 &lt;- epci_geo[departement_44, , op = st_within] mapview(list(departement_44, epci_d44), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = FALSE) L’opération de filtre sur les données spatiales fonctionne en prenant la table en entrée (epci_geo), la table avec laquelle on souhaite définir les lignes à garder (departement_44), et l’opérateur qui va définir le test entre les deux géométries. Ici cet opérateur est st_within(x, y), qui renvoie TRUE si la géométrie de x est contenue à l’intérieur de celle de y. On peut spécifier différents prédicats spatiaux pour réaliser ce filtre. En deuxième argument des [ , , ], on peut ajouter, comme dans une opération [ classique de R, les colonnes que l’on souhaite garder. On peut aussi écrire en tidyverse : # 1er méthode epci_d44 &lt;- epci_geo %&gt;% st_filter(departement_44, .predicate = st_within) # 2e méthode epci_d44 &lt;- epci_geo %&gt;% filter(st_within(., departement_44, sparse = FALSE)) Il faut noter la présence du paramètre sparse = FALSE. L’option sparse est abordée dans la partie Prédicats spatiaux. Il faut retenir que pour utiliser les prédicats à l’intérieur de la fonction filter, il faut utiliser l’option sparse = FALSE. On voit ici que le résultat n’est pas très concluant : il manque 3 EPCI du département, ceux qui sortent des frontières de celui-ci. Prenons un buffer autour du département. Qu’est ce qu’un buffer ? C’est un tampon qui va nous permettre d’appliquer une transformation sur un objet vectoriel. A partir d’une couche de départ de type ponctuel, linéaire ou polygonal, le buffer va créer une nouvelle couche vectorielle. La géométrie de cette couche représente des objets surfaciques dont les frontières sont positionnées à une distance euclidienne, définie par l’utilisateur, des limites des objets vectoriels de la couche de départ. La fonction qui permet de faire cela avec sf s’appelle st_buffer(). st_buffer() prend en paramètre : un objet de classe sf une distance dont l’unité est définie par celle de l’objet sf, que l’on peut obtenir comme ceci st_crs(x)$units. departement_44_buffer &lt;- departement_44 %&gt;% st_buffer(dist = 5000) mapview(list(departement_44_buffer, departement_44), legend = FALSE, layer.name = c(&quot;Loire-Atlantique avec un buffer de 5 km&quot;, &quot;Loire-Atlantique&quot;), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_DEP&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;)) epci_d44_buffer &lt;- epci_geo[departement_44_buffer, , op = st_within] mapview(list(departement_44_buffer, epci_d44_buffer), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = FALSE) On récupère 2 des 3 EPCI manquant ainsi. Celui qui manque est l’EPCI de Redon qui est à cheval sur la Loire-Atlantique, le Morbihan et l’Île et Vilaine. Une méthode pour le récupérer est de prendre l’opérateur de filtre st_intersect au lieu de st_within en utilisant un buffer légèrement négatif de notre département pour ne pas récupérer tous les EPCI limitrophes. departement_44_buffer_negatif &lt;- departement_44 %&gt;% st_buffer(dist = -2000) epci_d44 &lt;- epci_geo[departement_44_buffer_negatif, , op = st_intersects] mapview(list(departement_44, epci_d44), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = FALSE) On aurait pu obtenir le même résultat en prenant les EPCI à l’intérieur du département 44 (avec st_within) ainsi que les EPCI qui chevauchent (avec st_overlaps) le département 44. epci_d44 &lt;- epci_geo %&gt;% filter(st_within(., departement_44, sparse = FALSE) | st_overlaps(., departement_44, sparse = FALSE)) mapview(list(departement_44, epci_d44), zcol = c(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;), legend = FALSE) 6.2 Prédicats spatiaux Les prédicats spatiaux décrivent les relations spatiales entre objets. Pour bien les illustrer, on va utiliser quelques données de notre création. Nous allons utiliser un polygone (a), des lignes (l) et des points (p), que nous créons à partir de leur coordonnées. # polygone (a - orange) a_poly &lt;- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1)))) a &lt;- st_sfc(a_poly) # lignes (l - bleues) l1 &lt;- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1)))) l2 &lt;- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0)))) l &lt;- st_sfc(l1, l2) # multi-points (p - noirs) p_matrix &lt;- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2) p_multi &lt;- st_multipoint(x = p_matrix) p_multi p &lt;- st_cast(st_sfc(p_multi), &quot;POINT&quot;) La fonction st_cast sert à passer d’un type de géométrie à l’autre, ici on transforme un multi-points en points. A partir de ces objets, on peut se poser les questions suivantes : Quels sont les points de p contenus dans le triangle a ? Quels sont les points de p qui ne sont pas contenus dans le triangle a ? Quels sont les points de p qui touchent le triangle a ? Quelles sont les lignes de l contenues dans a ? Les prédicats spatiaux servent à répondre à ces questions et sf contient une liste de fonctions dédiée à l’une ou l’autre de ces questions. st_intersects() permet de répondre à la première question, à savoir quels points de p sont dans a. st_intersects(p, a) Sparse geometry binary predicate list of length 4, where the predicate was `intersects&#39; 1: 1 2: 1 3: (empty) 4: (empty) L’opposé de st_intersects() est st_disjoint() : st_disjoint(x,y) renvoie TRUE pour les objets de x non reliés à y. st_disjoint(p, a) Sparse geometry binary predicate list of length 4, where the predicate was `disjoint&#39; 1: (empty) 2: (empty) 3: 1 4: 1 Le résultat de cette opération est une liste. Par défaut, la fonction st_intersect() renvoie une matrice creuse7. Cette structure permet d’économiser de la mémoire en n’enregistrant que les relations qui existent. Sur une opération de ce type, le gain est peu évident, mais quand on travaille sur des objets plus complexes, le gain est appréciable. Si on souhaite mieux utiliser cette information, on peut vouloir privilégier la matrice dense, qui renvoie une matrice de booléen pour chaque relation possible. Pour cela on peut utiliser l’option sparse = FALSE, ‘sparse’ signifiant en anglais ‘clairsemé’. st_intersects(p, a, sparse = FALSE) [,1] [1,] TRUE [2,] TRUE [3,] FALSE [4,] FALSE st_within() est une variante de st_intersect() qui ne renvoie TRUE que pour les points strictement à l’intérieur du polygone. st_within(p, a, sparse = FALSE) [,1] [1,] TRUE [2,] FALSE [3,] FALSE [4,] FALSE Une variante de st_within() permet d’ajouter un critère de distance pour intégrer des points presque dans le polygone, st_is_within_distance(). st_is_within_distance(p, a, dist = 0.8) Sparse geometry binary predicate list of length 4, where the predicate was `is_within_distance&#39; 1: 1 2: 1 3: (empty) 4: 1 st_touches() permet de récupérer les points qui touchent le polygone sans sans être à l’intérieur du polygone. st_touches(p, a, sparse = FALSE) [,1] [1,] FALSE [2,] TRUE [3,] FALSE [4,] FALSE st_contains(x,y) est équivalent à st_within(y,x). Par exemple si nous voulons savoir lesquelles de nos lignes l sont contenues dans a. st_contains(a, l, sparse = FALSE) [,1] [,2] [1,] FALSE TRUE Equivalent à : st_within(l, a, sparse = FALSE) [,1] [1,] FALSE [2,] TRUE st_crosses() renvoie TRUE si l’intersection des deux géométries est une géométrie de dimension n-1 ou n est le maximum des dimensions des deux objets et si l’intersection est à l’intérieur des deux objets. st_crosses(l, a, sparse = FALSE) [,1] [1,] TRUE [2,] FALSE Il existent encore d’autres prédicats qu’on ne détaillera pas ici : st_covers() st_covered_by() st_equals() et st_equals_exact() st_contains_properly() st_overlaps() 6.2.1 Exercice 1 - manipuler des objets sf Créer un objet contenant les points de p qui intersectent le polygone a, à partir du code suivant : library(sf) library(tidyverse) # polygone (a - orange) a_poly &lt;- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1)))) a &lt;- st_sfc(a_poly) # lignes (l - bleues) l1 &lt;- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1)))) l2 &lt;- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0)))) l &lt;- st_sfc(l1, l2) # multi-points (p - noirs) p_matrix &lt;- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2) p_multi &lt;- st_multipoint(x = p_matrix) p &lt;- st_cast(st_sfc(p_multi), &quot;POINT&quot;) Résultat attendu : # A tibble: 2 × 1 p &lt;POINT&gt; 1 (0.5 0) 2 (1 1) Visualisation graphique : 6.3 Les jointures spatiales Les jointures attributaires se basent sur un appariement entre une liste des variables présentes dans les deux tables. Les jointures spatiales se basent sur un appariement géographique, c’est à dire sur un espace géo commun. 6.3.1 Jointure de points avec des polygones Ce cas est relativement simple, une jointure spatiale entre une liste de points et une liste de polygones va attribuer pour chaque point le ou les polygones auquel il appartient. On va utiliser ici le fichier sirene du département de Loire Atlantique géocodé par Christian Quest8. Prenons les entreprises de production de sel (code APE ‘0893Z’) sur ce département et regardons dans quelle partie du territoire elles se trouvent. load(&quot;extdata/sirene.RData&quot;) sirene44_sel &lt;- sirene44 %&gt;% filter(APET700 == &quot;0893Z&quot;) mapview(list(departement_44, epci_d44, sirene44_sel), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;, &quot;NOMEN_LONG&quot;), legend = FALSE) Nous allons réaliser une jointure spatiale pour récupérer le code sirene de l’EPCI où se trouve chaque entreprise. sirene44_sel_avec_code_epci &lt;- sirene44_sel %&gt;% st_join(epci_geo) mapview(list(departement_44, epci_d44, sirene44_sel_avec_code_epci), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;, &quot;NOM_EPCI&quot;), legend = FALSE) Une jointure entre deux couches de données géographiques demande à ce que celles-ci partagent la même projection. 6.3.2 Jointure de polygones avec des polygones A la différence des appariements entre points et polygones, la jointure spatiales entre deux couches de polygones nécessite quelques critères complémentaires : souhaite-t-on joindre deux polygones dès qu’ils s’intersectent ? Souhaite-t-on joindre à un polygone de la première couche à celui de la deuxième avec lequel il partage le plus de surface en commun ? Par exemple, imaginons que nous voulions joindre notre couche des EPCI avec celle des départements, souhaite-t-on que l’EPCI de Redon se retrouve apparié avec tous les départements auxquels il appartient, ou seulement le département dans lequel il est principalement situé ? epci_d44_avec_departement &lt;- epci_d44 %&gt;% st_join(departements_geo %&gt;% st_buffer(dist = -1000)) names(epci_d44_avec_departement) [1] &quot;ID.x&quot; &quot;CODE_EPCI&quot; &quot;NOM_EPCI&quot; &quot;TYPE_EPCI&quot; &quot;ID.y&quot; &quot;NOM_DEP&quot; [7] &quot;INSEE_DEP&quot; &quot;INSEE_REG&quot; &quot;AREA&quot; &quot;geometry&quot; epci_d44_avec_departement %&gt;% select(NOM_EPCI, NOM_DEP) %&gt;% group_by(NOM_EPCI) %&gt;% tally() %&gt;% arrange(-n) # A tibble: 17 × 3 NOM_EPCI n geometry &lt;fct&gt; &lt;int&gt; &lt;MULTIPOLYGON [m]&gt; 1 CA Redon Agglomération 3 (((306620 6741720, 30626… 2 CA de la Presqu&#39;île de Guérande Atlantique (… 2 (((276339 6716135, 27628… 3 CC du Pays d&#39;Ancenis 2 (((371339 6714790, 37131… 4 CA Clisson Sèvre et Maine Agglo 1 (((363286 6675340, 36313… 5 CA de la Région Nazairienne et de l&#39;Estuaire… 1 (((302551 6716906, 30254… 6 CA Pornic Agglo Pays de Retz 1 (((308476 6686309, 30859… 7 CC Châteaubriant-Derval 1 (((352474 6745979, 35243… 8 CC d&#39;Erdre et Gesvres 1 (((344433 6712377, 34443… 9 CC de Grand Lieu 1 (((350722 6678570, 35073… 10 CC de la Région de Blain 1 (((347300 6718329, 34716… 11 CC de Nozay 1 (((348972 6729772, 34899… 12 CC du Pays de Pontchâteau Saint-Gildas-des-B… 1 (((316649 6727168, 31667… 13 CC du Sud-Estuaire 1 (((312929 6700671, 31338… 14 CC Estuaire et Sillon 1 (((321943 6705416, 32193… 15 CC Sèvre et Loire 1 (((369368 6686432, 36928… 16 CC Sud Retz Atlantique 1 (((336398 6673676, 33641… 17 Nantes Métropole 1 (((353637 6695899, 35362… Une jointure classique va donc rattacher 3 EPCI à plus de 1 département. Avec l’option largest = TRUE la jointure va attribuer aux EPCI le département avec lequel il partage le plus de surface. On voit ici que tout les EPCI adhérents à la Loire-Atlantique se retrouvent alors rattachés à la Loire-Atlantique. epci_d44_avec_departement &lt;- epci_d44 %&gt;% st_join(departements_geo %&gt;% st_buffer(dist = -1000), largest = TRUE) mapview(list(departement_44, epci_d44, sirene44_sel_avec_code_epci), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_EPCI&quot;, &quot;NOM_EPCI&quot;), legend = FALSE) st_join() utilise par défaut le prédicat st_intersects, dans le paramètre join. Après une jointure spatiale, le dataframe résultat contient la géométrie du jeu de données de gauche (càd le 1er jeu de données passé dans les arguments de st_join()). 6.3.3 Exercice 2 : exploitation des données DVF en API Le but de cet exercice va être d’exploiter les données DVF sur les transactions immobilières dans l’ancien et la carte des quartiers de Nantes pour obtenir des indicateurs des transactions par quartier. On va utiliser pour DVF l’API mise en place par Christian Quest : http://api.cquest.org/dvf. ## Activation des packages library(httr) library(jsonlite) library(sf) library(tidyverse) get_dvf &lt;- GET(&quot;http://api.cquest.org/dvf?code_commune=44109&quot;) dvf_content &lt;- content(get_dvf, &quot;text&quot;, encoding = &quot;UTF-8&quot;) dvf_json &lt;- fromJSON(dvf_content)$resultats %&gt;% # On ne garde que les données avec une géolocalisation valide, un prix et une surface renseignés. filter(!is.na(lon), !is.na(lat), !is.na(valeur_fonciere), !is.na(surface_relle_bati)) dvf &lt;- st_as_sf(dvf_json, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326) Contour des quartiers de Nantes, ils proviennent de Nantes Métropole Open Data :https://data.nantesmetropole.fr quartier_nantes &lt;- st_read(&quot;https://data.nantesmetropole.fr/explore/dataset/244400404_quartiers-communes-nantes-metropole/download/?format=geojson&amp;disjunctive.libcom=true&amp;refine.libcom=Nantes&amp;timezone=Europe/Berlin&amp;lang=fr&quot;) quartier_nantes &lt;- st_set_crs(quartier_nantes, 4326) On veut produire les infos suivantes par quartier et année : Volume de ventes (nb) Pourcentage de maisons dans les ventes Prix moyen au m2 par type de bien Résultat attendu : Rows: 66 Columns: 8 $ quartier &lt;chr&gt; &quot;Ile de Nantes&quot;, &quot;Ile de Nantes&quot;, &quot;Ile de Nantes&quot;,… $ annee_mutation &lt;dbl&gt; 2014, 2015, 2016, 2017, 2018, 2019, 2014, 2015, 20… $ nb_ventes &lt;dbl&gt; 255, 346, 405, 464, 475, 221, 212, 203, 196, 224, … $ pourcentage_maison &lt;dbl&gt; 1.960784, 2.312139, 2.962963, 1.293103, 1.263158, … $ prix_m2_appartement &lt;dbl&gt; 4227.436, 2720.641, 3583.049, 3496.280, 3574.651, … $ prix_m2_maison &lt;dbl&gt; 3208.333, 2961.019, 19695.106, 3519.273, 4144.621,… $ prix_m2_ensemble &lt;dbl&gt; 4187.948, 2728.811, 4208.121, 3496.700, 3587.453, … $ geometry &lt;POLYGON [°]&gt; POLYGON ((-1.518491 47.2105..., POLYGON ((… 6.4 Les mesures Contrairement aux opérations précédentes qui sont binaires, les opérations de mesure sont continues. 6.4.1 Calcul de surface Le calcul de surface se fait à l’aide de la fonction st_area(). Le résultat sera exprimé dans l’unité du crs. st_area(epci_d44) Units: [m^2] [1] 327171752 451105821 311573694 277485664 425120290 884405865 313277739 [8] 995291184 533909100 300537854 214300118 509590978 275642240 865087496 [15] 223059032 396227313 333955602 6.4.2 Matrice de distances Les distances se calculent avec la fonction st_distance(). centres_departements_pdl &lt;- st_centroid(departements_geo) %&gt;% filter(INSEE_REG == &quot;52&quot;) st_distance(centres_departements_pdl) Units: [m] 1 2 3 4 5 1 0.00 84564.06 115956.62 159032.47 81705.88 2 84564.06 0.00 84434.09 89195.57 97175.56 3 115956.62 84434.09 0.00 67722.46 170458.60 4 159032.47 89195.57 67722.46 0.00 186168.94 5 81705.88 97175.56 170458.60 186168.94 0.00 Trois choses à noter sur le résultat : st_distance() retourne une matrice… … contenant toute les distances calculables 2 à 2… …et qui a un paramètre Units nous donnant l’unité de mesure des distances calculées. Ici on calcule notre matrice sur un seul objet. Vous pouvez calculer des distances entre deux objets x et y de classe sf. Dans ce cas il fera le calcul des distances pour toutes les combinaisons possibles d’objets de x et de y. Une option de st_distance() vous permet de limiter le résultat aux calculs 2 à 2 : by_element = TRUE. Dans ce cas le résultat est un vecteur. 6.4.3 Identification du plus proche voisin Un besoin fréquent en géomatique est d’identifier l’objet le plus proche d’un autre. La fonction qui permet cela est st_nearest_feature(). Prenons l’ensemble des départements français, et trouvons celui de la région qui leur est le plus proche. On va utiliser les centroïdes pour alléger le calcul. index_dep_pdl &lt;- st_nearest_feature( departements_geo, centres_departements_pdl ) index_dep_pdl [1] 4 4 4 4 4 4 4 4 4 4 5 4 5 5 5 3 2 5 5 4 5 4 1 2 5 4 4 4 4 1 5 5 5 5 5 3 4 4 [39] 4 4 5 4 4 2 1 4 5 5 5 2 3 4 4 3 4 4 1 4 4 4 4 3 4 4 5 5 5 4 4 4 4 4 4 4 4 4 [77] 4 4 4 2 4 5 5 2 2 5 2 2 4 4 4 4 4 4 4 4 st_nearest_feature() renvoie un vecteur d’index en résultat. Pour visualiser cet index, vous pouvez utiliser ensuite la fonction st_nearest_point() qui va permettre de faire un lien entre les départements et le département ligérien le plus proche. st_nearest_point() permet en effet de renvoyer pour deux géométries la ligne rejoignant les 2 points les plus proches. liens &lt;- st_nearest_points(departements_geo, centres_departements_pdl[index_dep_pdl, ], pairwise = TRUE ) ggplot() + geom_sf(data = departements_geo) + geom_sf(data = liens) On peut utiliser aussi st_nearest_feature() comme un mode de jointure des données. departements_join &lt;- st_join(departements_geo, centres_departements_pdl, join = st_nearest_feature ) ggplot() + geom_sf(data = departements_join, aes(fill = NOM_DEP.y)) + labs( title = &quot;Département ligérien le plus proche de chaque département français&quot;, fill = NULL ) 6.5 Carroyage 6.5.1 Créer une grille régulière La fonction st_make_grid() permet de créer une grille régulière à partir d’un objet géo. Elle produit un objet rectangulaire de type sfc, il faut ensuite utiliser la fonction st_sf() pour transformer cet objet sfc en objet sf. Lors de cette transformation nous rajoutons ici une colonne d’identifiants uniques. grille &lt;- st_make_grid(epci_d44, cellsize = 10000) %&gt;% st_as_sf() %&gt;% rowid_to_column(&quot;id&quot;) mapview(grille) + mapview(epci_d44, col.regions = &quot;white&quot;, alpha.regions = 0.5) On constate que plusieurs carreaux sont inutiles. On peut réduire leur nombre avec st_intersects() comme vu précédemment. grille_ajustee &lt;- grille[epci_d44, , op = st_intersects] mapview(grille_ajustee) + mapview(epci_d44, col.regions = &quot;white&quot;, alpha.regions = 0.5) 6.5.2 Compter des points dans un polygone On cherche ici à compter par carreau, le nombre d’entreprises de type “Boulangerie et boulangerie-pâtisserie” (code APE 1071C) du fichier sirene 44 . boul_44 &lt;- filter(sirene44, APET700 == &quot;1071C&quot;) %&gt;% select(SIREN, NOMEN_LONG) mapview(grille_ajustee) + mapview(epci_d44, col.regions = &quot;white&quot;, alpha.regions = 0.5) + mapview(boul_44, col.regions = &quot;grey&quot;) La grille ajustée comprend 113 carreaux. Le 44 comprend 717 boulangeries. intersection &lt;- st_intersects(grille_ajustee, boul_44, sparse = TRUE) dim(intersection) [1] 113 717 L’objet intersection est une liste de la longueur de l’objet grille_ajustee et chaque élément de la liste contient le ou les index des éléments de l’objet boul_44 qu’il intersecte. Exemple avec le 46e carreau : intersection[[46]] [1] 92 359 383 652 653 655 Le 46e carreau comprend les boulangeries des lignes 92, 359, 383, 652, 653, 655 de la table boul_44. Pour compter le nombre de boulangeries par carreau, on peut parcourir la liste et reporter la longueur de chacun de ces éléments. grille_boul &lt;- mutate(grille_ajustee, nb_boulang = map_dbl(intersection, length)) select(grille_boul, nb_boulang) %&gt;% plot Une autre solution est de passer par les jointures spatiales : nb_boul_par_carreau &lt;- st_join(x = grille_ajustee, y = boul_44) %&gt;% group_by(id) %&gt;% summarise(nb_boulang = length(SIREN)) select(nb_boul_par_carreau, nb_boulang) %&gt;% plot https://fr.wikipedia.org/wiki/%C3%89tablissement_public_de_coop%C3%A9ration_intercommunale↩︎ https://fr.wikipedia.org/wiki/Matrice_creuse↩︎ http://data.cquest.org/geo_sirene/↩︎ "],["operations-geometriques.html", "Chapitre 7 Les opérations géométriques 7.1 Opérations unaires 7.2 Opérations binaires", " Chapitre 7 Les opérations géométriques Nous allons voir dans ce chapitre comment opérer des opérations géométriques sur nos vecteurs. Dans ce chapitre, nous allons utiliser les packages suivants. # CRAN library(sf) library(tidyverse) library(mapview) library(rmapshaper) library(cowplot) On distingue deux types d’opérations : les opérations unaires et binaires. 7.1 Opérations unaires 7.1.1 Simplification La simplification revient comme son nom l’indique à simplifier une couche vectorielle. Le cas d’usage d’un tel procédé peut être un changement d’échelle et plus généralement le besoin de réduire la taille de stockage de notre objet (par exemple pour une publication ou une carte interactive). Le package sf contient une fonction st_simplify qui implémente l’algorithme de Douglas-Peucker9 de GEOS. La fonction utilise le paramètre dTolerance pour controler le niveau de simplification. load(&quot;extdata/admin_express.RData&quot;) departement_56 &lt;- departements_geo %&gt;% filter(INSEE_DEP == &quot;56&quot;) departement_56_simplifie &lt;- departement_56 %&gt;% st_simplify(dTolerance = 900) departement_56_super_simplifie &lt;- departement_56 %&gt;% st_simplify(dTolerance = 2000) p1 &lt;- ggplot() + geom_sf(data = departement_56) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) p2 &lt;- ggplot() + geom_sf(data = departement_56_simplifie) + theme_void() p3 &lt;- ggplot() + geom_sf(data = departement_56_super_simplifie) + theme_void() plot_grid(p1, p2, p3, nrow = 1, labels = c(&#39;departement 56&#39;, &#39;simplifié&#39;, &#39;super simplifié&#39;)) On peut mesurer le gain réalisé par chaque opération. Une simplification avec un dTolerance de 900 permet d’économiser 91.2 % du stockage. Une simplification avec un dTolerance de 2000 permet d’économiser 92.2 % du stockage. object.size(departement_56) 451008 bytes object.size(departement_56_simplifie) 39496 bytes object.size(departement_56_super_simplifie) 34976 bytes Le problème de l’algorithme Douglas-Peucker est qu’il simplifie les géométries objet par objet. Cela conduit à perdre la topologie, et à des trous ou des chevauchements. L’option preserveTopology = TRUE de st_simplify() doit permettre en théorie d’éviter ce problème, mais ne marche pas au delà d’un certain seuil. Par exemple, prenons 2 départements autour du Morbihan. departements_35_44_56 &lt;- departements_geo %&gt;% filter(INSEE_DEP %in% c(&quot;35&quot;, &quot;44&quot;, &quot;56&quot;)) departements_35_44_56_super_simplifie &lt;- departements_35_44_56 %&gt;% st_simplify(dTolerance = 3000) p1 &lt;- ggplot() + geom_sf(data = departements_35_44_56) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) p3 &lt;- ggplot() + geom_sf(data = departements_35_44_56_super_simplifie) + theme_void() plot_grid(p1, p3, nrow = 1) On constate clairement des trous à la frontière des 3 départements. Un autre algorithme peut être utilisé qui n’a pas les mêmes limitations, l’algorithme de Visvalingam10. Le package rmapshaper contient une fonction ms_simplify() qui implémente cet algorithme. Ce package est une interface vers Mapshaper11, un site en ligne d’édition de données cartographiques. departements_35_44_56 &lt;- departements_35_44_56 %&gt;% mutate(AREA = as.numeric(AREA)) departements_35_44_56_ms_simplifie &lt;- ms_simplify(departements_35_44_56, method = &quot;vis&quot;, keep = 0.01) p1 &lt;- ggplot() + geom_sf(data = departements_35_44_56) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) p3 &lt;- ggplot() + geom_sf(data = departements_35_44_56_ms_simplifie) + theme_void() plot_grid(p1, p3, nrow = 1) 7.1.2 Centroïde Le centroïde permet d’identifier le centre d’un objet géométrique. Il y a plusieurs façons de définir un centroïde. La plus usuelle est le centroïde géographique, qui peut être défini comme le point d’équilibre d’un objet (celui en dessous duquel votre doigt peut faire tenir en équilibre cet objet). La fonction permettant de définir un centroïde dans sf est st_centroid(). centres_departements &lt;- st_centroid(departements_geo) ggplot() + geom_sf(data = departements_geo) + geom_sf(data = centres_departements, color = &quot;dark green&quot;, size = .5) + theme_void() + theme(panel.grid = element_blank(), panel.border = element_blank()) + labs(title = &quot;les départements et leur centroïdes&quot;) Parfois, le centroïde peut se placer en dehors de l’objet lui même. Par exemple pensez à un atoll. Dans ce cas, on peut utiliser st_point_on_surface() qui garantit que le point est sur la surface de l’objet de départ. Egalement, en cas d’objets multipolygonaux, comme par exemple un chapelet d’îlets, la fonction st_centroid() accepte un argument booléen of_largest_polygon à utiliser pour forcer le positionnement du point sur le plus gros polygone. centr_dep &lt;- st_centroid(departements_geo, of_largest_polygon = TRUE) 7.1.3 Buffer Comme déjà vu, à partir d’une couche de départ de type ponctuel, linéaire ou polygonal, le buffer va créer une nouvelle couche vectorielle. La géométrie de cette couche représente des objets surfaciques dont les frontières sont positionnées à une distance euclidienne, définie par l’utilisateur, des limites des objets vectoriels de la couche de départ. departement_44 &lt;- departements_geo %&gt;% filter(INSEE_DEP == &quot;44&quot;) departement_44_buffer &lt;- departement_44 %&gt;% st_buffer(dist = 5000) mapview(list(departement_44_buffer, departement_44), layer.name = list(&quot;Loire-Atlantique avec un buffer de 5 km&quot;, &quot;Loire-Atlantique&quot;), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_DEP&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;), legend = FALSE) 7.2 Opérations binaires 7.2.1 Transformation affine Les tranformations affines regroupent les transformations qui préservent les lignes et le parallélisme. A l’inverse les angles et les tailles ne le sont pas forcément. Les transformations affines intègrent notamment les translations, les rotations et les changements d’échelle. Le package sf implémente ces transformations pour les objets de classe sfg et sfc. 7.2.1.1 Translation departement_44_sfc &lt;- st_geometry(departement_44) departement_44_sfc_trans &lt;- departement_44_sfc + c(10000, 10000) departement_44_trans &lt;- st_set_geometry(departement_44, departement_44_sfc_trans) st_crs(departement_44_trans) &lt;- st_crs(departement_44) mapview(list(departement_44_trans, departement_44), layer.name = list(&quot;Loire-Atlantique avec déplacement affine de 10 km vers le nord et 10 km vers le sud&quot;, &quot;Loire-Atlantique&quot;), zcol = list(&quot;NOM_DEP&quot;, &quot;NOM_DEP&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;), legend = FALSE) 7.2.1.2 Changement d’échelle Dans l’exemple suivant on va réduire par deux la surface de chacun des EPCI du département. Pour cela on va recentrer les EPCI pour que les coodonnées des centroides soient à l’origine, avant de diviser par deux les cordonnées des contours et réappliquer la translation au centroid. epci_d44 &lt;- st_filter(x = epci_geo, y = departement_44 %&gt;% st_buffer(-3000), .predicate = st_intersects) epci_d44_sfc &lt;- st_geometry(epci_d44) epci_d44_centroid_sfc &lt;- st_centroid(epci_d44_sfc) epci_d44_centroid_sfc_scale &lt;- (epci_d44_sfc - epci_d44_centroid_sfc) * 0.5 + epci_d44_centroid_sfc epci_d44_centroid_scale &lt;- st_set_geometry(epci_d44, epci_d44_centroid_sfc_scale) st_crs(epci_d44_centroid_scale) &lt;- st_crs(epci_d44) mapview(list(epci_d44, epci_d44_centroid_scale), layer.name = list(&quot;Epci de Loire-Atlantique&quot;, &quot;Epci de Loire-Atlantique avec surface divisées par deux&quot;), zcol = list(&quot;NOM_EPCI&quot;, &quot;NOM_EPCI&quot;), col.regions = list(&quot;#440154FF&quot;, &quot;#FDE725FF&quot;), legend = FALSE) 7.2.2 Découpage Le découpage spatiale est une forme de filtre sur les géographies. Le découpage peut seulement s’appliquer à des formes plus complexes que des points : (multi-)lignes, (multi-)polygones. Nous allons illustrer le découpage à partir des EPCI à cheval sur plusieurs départements. epci_redon &lt;- epci_d44 %&gt;% filter(CODE_EPCI == &quot;243500741&quot;) st_intersection() permet de garder la partie commune des deux géométries. redon_et_departement_44 &lt;- st_intersection(epci_redon, departement_44) %&gt;% mutate(NOM_EPCI = &quot;Communes du 44\\ndans la CA de Redon&quot;) st_difference(x,y) permet de ne garder que la partie de x absente de y redon_hors_departement_44 &lt;- st_difference(epci_redon, departement_44) %&gt;% mutate(NOM_EPCI = &quot;Com. de la CA de Redon hors 44&quot;) st_sym_difference(x,y) permet de ne garder que les parties de distinctes x et de y. redon_et_departement_44_sans_partie_communes &lt;- st_sym_difference(epci_redon, departement_44) %&gt;% mutate(NOM_EPCI = &quot;Communes du 44 et du CA Redon Agglomération hors communes en commun&quot;) 7.2.3 Union st_union() permet de fusionner les géométries de plusieurs objets. On va regarder comment reconstituer la carte des régions à partir de celle des départements. regions &lt;- departements_geo %&gt;% group_by(INSEE_REG) %&gt;% summarise(do_union = TRUE) mapview(regions, legend = FALSE) Derrière cette opération, summarise() utilise st_union() du package sf pour dissourdre les polygones des départements en un seul polygone régional. regions_52 &lt;- departements_geo %&gt;% filter(INSEE_REG == &quot;52&quot;) regions_52 &lt;- st_union(regions_52) Douglas, David H, and Thomas K Peucker. 1973. “Algorithms for the Reduction of the Number of Points Required to Represent a Digitized Line or Its Caricature.” Cartographica: The International Journal for Geographic Information and Geovisualization 10 (2): 112–22.↩︎ Visvalingam, M., and J. D. Whyatt. 1993. “Line Generalisation by Repeated Elimination of Points.” The Cartographic Journal 30 (1): 46–51. https://doi.org/10.1179/000870493786962263.↩︎ https://mapshaper.org/↩︎ "],["les-reprojections.html", "Chapitre 8 Les reprojections 8.1 Un premier exemple de reprojection 8.2 Quand reprojeter ? 8.3 Quel CRS utiliser ? 8.4 Comment projeter ?", " Chapitre 8 Les reprojections Dans ce chapitre, nous allons utiliser les librairies suivantes. # CRAN library(cowplot) library(mapview) library(sf) library(tidyverse) library(tmap) Pour rappel, il existe deux types de CRS, les CRS géographiques (longitude/latitude avec pour unité de compte des degrés) et les CRS projetés (avec un datum et une unité en mètre par exemple). Autrefois, la plupart des fonctions de sf présupposaient de travailler avec un CRS projeté, car les fonctions de GEOS sur lesquelles elles se basent, le nécessitaient aussi. 8.1 Un premier exemple de reprojection Prenons les coordonnées de Nantes en WGS 84: nantes &lt;- data.frame(lon = -1.553621, lat = 47.218371) %&gt;% st_as_sf(coords = c(&quot;lon&quot;, &quot;lat&quot;)) %&gt;% st_set_crs(4326) On peut visualiser nos données mapview(nantes) st_is_longlat() est une fonction de sf qui permet de faire un test sur la famille de CRS à laquelle on a affaire. st_is_longlat(nantes) [1] TRUE Essayons de créer un buffer de 1 km autour de Nantes. nantes_buffer &lt;- st_buffer(nantes, dist = 1000) mapview(list(nantes, nantes_buffer)) Le buffer est pixelisé en longitude / latitude. Tentons une reprojection. La fonction permettant une reprojection est st_transform(). On va ici passer en Lambert 93 nos données. nantes_proj &lt;- st_transform(nantes, 2154) Le CRS lambert 93 est bien un CRS projeté : st_is_longlat(nantes_proj) [1] FALSE nantes_proj_buffer &lt;- st_buffer(nantes_proj, dist = 1000) mapview(list(nantes_proj, nantes_proj_buffer)) Les contours du buffer sont cette fois plus nets, également les mesures de surfaces sont plus précises en utilisant un crs projeté, adapté à la zone observée. st_area(nantes_buffer) 3185131 [m^2] st_area(nantes_proj_buffer) 3140157 [m^2] pi*1000^2 [1] 3141593 8.2 Quand reprojeter ? Quelques cas usuels qui peuvent vous amener à reprojeter vos données : la manipulation de données fournies dans des CRS différents l’usage du package leaflet impose des données spécifiées en WGS 84 le besoin de visualiser vos données suivant la conversion de certaines propriétés des objets à la surface de la terre. l’usage de fonctions recommandant d’utiliser des CRS projetés (comme st_buffer(), st_area() ci-dessus) Un exemple d’usage : la distance de Rennes à Nantes Prenons les coordonnées WGS 84 de Rennes rennes &lt;- data.frame(lon = -1.6777926, lat = 48.117266) %&gt;% st_as_sf(coords = c(&quot;lon&quot;, &quot;lat&quot;)) %&gt;% st_set_crs(4326) mapview(rennes) Tentons de calculer la distance de Rennes à Nantes. Avec la données en Lambert 93, la fonction st_distance() renvoie un message d’erreur. st_distance(rennes, nantes_proj) Error in st_distance(rennes, nantes_proj): st_crs(x) == st_crs(y) is not TRUE Avec la données en WGS 84, la fonction st_distance() renvoie bien un résultat. st_distance(rennes, nantes) Units: [m] [,1] [1,] 100384.2 Avec la données en Lambert 93, la fonction st_distance() renvoie un résultat plus précis : st_distance(rennes %&gt;% st_transform(2154), nantes_proj) Units: [m] [,1] [1,] 100302.7 8.3 Quel CRS utiliser ? A cette question, il y a rarement une seule bonne réponse. En ce qui concerne les CRS géométriques, le plus simple est d’utiliser le WGS 84 (EPSG 4326), qui est de loin le plus populaire, avec lequel beaucoup de données sont fournies. En ce qui concerne les CRS projetés, il existe des CRS officiels à utiliser préférentiellement pour les données françaises. En métropole, on utilise le Lambert 93 (EPSG 2154). Pour les DROM, on utilise les CRS : RGAF09 / UTM zone 20N, code EPSG 5490, pour les Antilles françaises, RGFG95 / UTM zone 22N, code EPSG 2972, pour la Guyane, RGR92 / UTM zone 40S, code EPSG 2975, pour la Réunion, RGM04 / UTM zone 38S, code EPSG 4471, pour Mayotte. Ensuite votre choix va dépendre des propriétés que vous souhaitez conserver. 8.4 Comment projeter ? 8.4.1 Projeter des vecteurs Reprojeter des données vecteur se fait à l’aide de la fonction st_transform(), que nous avons vue précédemment. 8.4.2 Modifier la projection d’une carte. Parfois on souhaite pouvoir aller plus loin dans les reprojections, en adaptant le centre de la projection, pour cela on peut utiliser une proj4string ad hoc. Pour cela, on va modifier l’argument +proj de notre crs avec st_transform. Tentons par exemple de reprojeter notre carte du globe en utilisant la projection azimutale équivalente de Lambert, centrée sur Pékin. data(&quot;World&quot;) World_pekin &lt;- st_transform(World, crs = &quot;+proj=laea +x_0=0 +y_0=0 +lon_0=116 +lat_0=40&quot;) Le paramètre +proj=laea permet de redéfinir la projection, les paramètres +lon_0 et lat_0 permettent de définir le centre de la projection. x_0 et y_0 définissent le centre du plan pour les coordonnées. Qu’est ce qui a changé entre nos deux cartes ? st_crs(World) Coordinate Reference System: User input: EPSG:4326 wkt: GEOGCRS[&quot;WGS 84&quot;, DATUM[&quot;World Geodetic System 1984&quot;, ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, LENGTHUNIT[&quot;metre&quot;,1]]], PRIMEM[&quot;Greenwich&quot;,0, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], CS[ellipsoidal,2], AXIS[&quot;geodetic latitude (Lat)&quot;,north, ORDER[1], ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], AXIS[&quot;geodetic longitude (Lon)&quot;,east, ORDER[2], ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], USAGE[ SCOPE[&quot;unknown&quot;], AREA[&quot;World&quot;], BBOX[-90,-180,90,180]], ID[&quot;EPSG&quot;,4326]] st_crs(World_pekin) Coordinate Reference System: User input: +proj=laea +x_0=0 +y_0=0 +lon_0=116 +lat_0=40 wkt: PROJCRS[&quot;unknown&quot;, BASEGEOGCRS[&quot;unknown&quot;, DATUM[&quot;World Geodetic System 1984&quot;, ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, LENGTHUNIT[&quot;metre&quot;,1]], ID[&quot;EPSG&quot;,6326]], PRIMEM[&quot;Greenwich&quot;,0, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8901]]], CONVERSION[&quot;unknown&quot;, METHOD[&quot;Lambert Azimuthal Equal Area&quot;, ID[&quot;EPSG&quot;,9820]], PARAMETER[&quot;Latitude of natural origin&quot;,40, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8801]], PARAMETER[&quot;Longitude of natural origin&quot;,116, ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ID[&quot;EPSG&quot;,8802]], PARAMETER[&quot;False easting&quot;,0, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8806]], PARAMETER[&quot;False northing&quot;,0, LENGTHUNIT[&quot;metre&quot;,1], ID[&quot;EPSG&quot;,8807]]], CS[Cartesian,2], AXIS[&quot;(E)&quot;,east, ORDER[1], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]], AXIS[&quot;(N)&quot;,north, ORDER[2], LENGTHUNIT[&quot;metre&quot;,1, ID[&quot;EPSG&quot;,9001]]]] "],["geocodage.html", "Chapitre 9 Géocodage 9.1 Géolocalisation à l’adresse 9.2 Digitalisation", " Chapitre 9 Géocodage # CRAN library(sf) library(tidyverse) library(mapview) library(mapedit) # Github # remotes::install_github(&quot;joelgombin/banR&quot;) library(banR) 9.1 Géolocalisation à l’adresse Plusieurs packages permettent de géocoder des adresses. Le package {tidygeocoder} utilise un grand nombre de services de géocodage en ligne et est international. Le package {banR} de Gombin et Chevalier, exploite l’API de la Base Adresse Nationale. Il s’intalle depuis github. Il est particulièrement approprié pour géocoder des adresses en France. mes_adresses &lt;- data.frame( services = c(&quot;DDTM76&quot;, &quot;CVRH Nantes&quot;, &quot;DREAL Pays de la Loire&quot;), adresses = c(&quot;Cité Administrative, 2 rue Saint Sever, 76000 ROUEN&quot;, &quot;25 Rue du Douet Garnier, 44000 Nantes&quot;, &quot;5 Rue Françoise Giroud, 44200 Nantes&quot;) ) mes_adresses_geoc &lt;- geocode_tbl(tbl = mes_adresses, adresse = adresses) mes_adresses_geoc # A tibble: 3 × 20 services adresses latitude longitude result_label result_score &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 DDTM76 Cité Admi… 49.4 1.10 2 Rue Saint… 0.520 2 CVRH Nantes 25 Rue du… 47.2 -1.57 25 Rue du D… 0.978 3 DREAL Pays de la Loire 5 Rue Fra… 47.2 -1.54 5 Rue Franç… 0.971 # ℹ 14 more variables: result_score_next &lt;chr&gt;, result_type &lt;chr&gt;, # result_id &lt;chr&gt;, result_housenumber &lt;chr&gt;, result_name &lt;chr&gt;, # result_street &lt;chr&gt;, result_postcode &lt;chr&gt;, result_city &lt;chr&gt;, # result_context &lt;chr&gt;, result_citycode &lt;chr&gt;, result_oldcitycode &lt;chr&gt;, # result_oldcity &lt;chr&gt;, result_district &lt;chr&gt;, result_status &lt;chr&gt; Le résultat est un df enrichi de 15 nouveaux attributs dont le nom commence par result_ + les champs longitude et latitude. mes_adresses_geoc %&gt;% select(starts_with(&quot;result_&quot;)) %&gt;% names() [1] &quot;result_label&quot; &quot;result_score&quot; &quot;result_score_next&quot; [4] &quot;result_type&quot; &quot;result_id&quot; &quot;result_housenumber&quot; [7] &quot;result_name&quot; &quot;result_street&quot; &quot;result_postcode&quot; [10] &quot;result_city&quot; &quot;result_context&quot; &quot;result_citycode&quot; [13] &quot;result_oldcitycode&quot; &quot;result_oldcity&quot; &quot;result_district&quot; [16] &quot;result_status&quot; Le champ result_score fournit un indicateur de la qualité de la géolocalisation. Il reste alors à transformer le résultat en df spatial, grâce à la fonction st_as_sf() vue au chapitre [lire-des-donnees-spatiales]. mes_adresses_sf &lt;- st_as_sf(mes_adresses_geoc, coords = c(&quot;longitude&quot;, &quot;latitude&quot;), crs = 4326) mapview(mes_adresses_sf) Pour en savoir plus : site web de {banR}, http://joelgombin.github.io/banR/. 9.2 Digitalisation Le package {mapedit} permet de digitaliser des fonds de carte directement dans R. Bien que pouvant se révéler pratique dans certains cas, ce package ne saurait se substituer aux fonctionnalités d’un SIG pour les tâches de numérisation importantes. "],["creer-des-cartes-avec-ggplot2.html", "Chapitre 10 Créer des cartes statiques avec {ggplot2} 10.1 Librairies 10.2 Introduction : les cartes statiques en R 10.3 Quelques rappels sur {ggplot2} 10.4 Faire des cartes avec {ggplot2} 10.5 Faire des cartes avec {mapfactory}", " Chapitre 10 Créer des cartes statiques avec {ggplot2} 10.1 Librairies Dans ce chapitre, nous allons utiliser les librairies suivantes : # CRAN library(cowplot) library(ggspatial) library(sf) library(tidyverse) #comprend ggplot2 # Github library(COGiter) # remotes::install_github(&quot;MaelTheuliere/COGiter&quot;) library(gouvdown) # remotes::install_github(&quot;spyrales/gouvdown&quot;) # Gitlab-forge library(mapfactory) # remotes::install_gitlab(&quot;dreal-pdl/csd/mapfactory&quot;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) 10.2 Introduction : les cartes statiques en R Il existe de nombreuses manières de visualiser des données géographiques dans R. Des instructions très concises suffisent pour disposer d’un premier aperçu. Prenons l’exemple de notre couche régionale issue de COGiter. library(COGiter) library(sf) En utilisant la fonction plot() basique de R sur un objet sf, R nous propose un rapide aperçu de la couche et de ses attributs : plot(COGiter::regions_geo) Le package {mapview} permet également d’afficher un aperçu de couche très rapidement, posé sur un fond de carte Open street map. library(mapview) mapview(x = COGiter::regions_geo) Le résultat est un widget html, explorable, zoomable, cliquable. Bien que conçu principalement pour faciliter l’exploration de données spatiales, {mapview} permet de personnaliser la mise en plage, d’empiler les couches… Ce ne sera pas vu lors de la formation, mais tout est très bien expliqué dans l’aide ?mapview() et sur le site de présentation du package, notamment sur la vignette de démarrage. Pour mettre en page des cartes, 3 packages se distinguent : {ggplot2}, {tmap}, et {mapsf} (successeur de {cartography}). {ggplot2} est un package du tidyverse, qui propose une syntaxe cohérente entre dataviz et cartoviz. Il dispose de templates à la Marque Etat, raison pour laquelle son utilisation est à privilégier au sein du pôle ministériel. {tmap} a longtemps été plus complet et plus simple que ggplot2. Il constituait un incontournable. Ce n’est plus le cas désormais. Son utilisation est détaillée en annexe pour mémoire. Le package {mapsf} a été développé par Timothé Giraud du CNRS. Ses fonctionnalités sont assez complètes et la prise en main est plutôt simple, pour des rendus graphiques très aboutis. De plus, le package est relativement léger. Un support de cours et une feuille de triche facilitent son appropriation. Comme l’utilisation de {ggplot2} est à privilégier au sein du pôle ministériel, ce package ne sera pas présenté lors de la formation. 10.3 Quelques rappels sur {ggplot2} {ggplot2} est un package de visualisation de données qui dispose de templates (thèmes, palettes) à la Marque Etat grâce au package {gouvdown}, créé par la communauté d’agents de l’Etat Spyrales. ggplot 2 a été créé par Hadley Wickham et Winston Chang pour implémenter dans R la vision développée par Leland Wilkinson dans The Grammar of Graphics (Statistics and Computing) de la conception de graphiques. Le but est de fournir une approche unique pour produire quasiment toute valorisation graphique de données que l’on peut trouver dans des revues scientifiques, les journaux, dans l’analyse statistique ou la data visualisation. Ce package aujourd’hui s’inscrit dans R dans le framework Tidyverse qui propose une approche cohérente sur l’ensemble de la chaîne de vie de la donnée : importation, préparation des données, analyse et valorisation. le tidyverse Se référer à la feuille de triche {ggplot2} permet de se lancer rapidement. 10.3.1 {ggplot2} : les concepts clefs Pour construire un graphique avec {ggplot2} il faut lui déclarer plusieurs éléments : la donnée à représenter : ggplot2 permet de travailler sur des vecteurs, des dataframes, des tibbles, ou des données spatiales ; le mapping : on définit dans l’aesthetic (ou aes) le mapping, c’est à dire ce que l’on veut représenter qui dépend des variables (quelle variable sur l’axe x, sur l’axe y, quelle variable pour définir une graduation de couleurs…), par exemple : x, y : pour les variables qui seront représentées selon les axes x et y ; colour : pour la variable qui sera représentée par la couleur (contour), fill : pour la variable qui sera représentée par la couleur de remplissage ; shape : pour la variable qui sera représentée par la forme du point, size : pour la variable qui sera représentée par la taille du point ou de la ligne, alpha : pour la variable qui sera représentée par la transparence du remplissage. les autres paramètres : on définit en dehors de l’aesthetic les autres paramètres graphiques constants (par exemple : je veux que toutes mes lignes soient rouges ou de taille 2 pixels) ; le layer (forme ou calque géométrique) : on définit sous quelle représentation graphique on représente les paramètres précédents (nuages de points, diagramme barres,…). Sous ggplot, ces fonctions sont de la forme geom_XX() ; le système de coordonnées : on définit quel type de système de coordonnées (polaire, cartésien…) on souhaite utiliser pour visualiser nos données. Par défaut ggplot utilise les coordonnées x, y cartésiennes. Si besoin de changer, on spécifie le système de coordonnées à l’aide d’une fonction de type coord_XX. L’écriture type d’un graphique ggplot sera donc : ggplot(data = &lt;DATA&gt;) + &lt;CALQUE_GEO&gt;(mapping = aes(&lt;MAPPINGS&gt;), ...=&lt;PARAMS&gt;) Voici un exemple appliqué au jeu de données d’exemple de R iris : Rows: 150 Columns: 5 $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.… $ Sepal.Width &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.… $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.… $ Petal.Width &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.… $ Species &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s… ggplot(data = iris) + geom_point(mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) Les fonctions de création de calques geom_XX incluent une transformation statistique par défaut (identité, décompte, quantile, classification…) grâce à leur paramètre “stat”, qu’il est possible de modifier au besoin. Par exemple la fonction geom_bar() est associé par défaut à la transformation stat_count() qui décompte les observations. ggplot(data = iris) + geom_bar(mapping = aes(x = Species, fill = Species)) On peut modifier ici le paramètre stat de geom_bar() pour afficher la moyenne des longueurs de sépales par espèces : ggplot(data = iris) + geom_bar(mapping = aes(x = Species, y = Sepal.Length, fill = Species), stat = &quot;summary&quot;) Les fonctions ggplot de création de calques géométriques de type geom_XX(stat = \"YY\") sont équivalentes aux fonctions stat_YY(geom = \"XX\"). ggplot(data = iris) + stat_summary(mapping = aes(x = Species, y = Sepal.Length, fill = Species), geom = &quot;bar&quot;) En résumé et en image : On va ensuite pouvoir partir de cette base pour l’enrichir avec des fonctions supplémentaires, comme le calibrage des palettes, le titre… Chaque fonction ggplot s’enchaîne avec des + comme les %&gt;%. Les paramètres graphiques se calibrent grâce aux fonctions scale_XX(), où XX est la propriété graphique à étalonner. Par exemple : distribution des communes selon leur population à partir du jeu de données d’exemple de COGiter pop2015. glimpse(pop2015) Rows: 35,441 Columns: 4 $ DEPCOM &lt;fct&gt; 01001, 01002, 01004, 01005, 01006, 01007, 01008, 01009,… $ pop2015 &lt;dbl&gt; 767, 241, 14127, 1619, 109, 2615, 747, 342, 1133, 390, … $ pop2015_a_part &lt;dbl&gt; 18, 1, 504, 33, 6, 107, 18, 9, 19, 11, 4, 3, 94, 5, 12,… $ pop2015_totale &lt;dbl&gt; 785, 242, 14631, 1652, 115, 2722, 765, 351, 1152, 401, … ggplot(pop2015, aes(x = pop2015_totale)) + geom_histogram(fill = &quot;lightblue&quot;) + scale_x_log10(labels = ~format(.x, big.mark = &quot; &quot;, scientific = FALSE), name = &quot;nombre d&#39;hab.&quot;) Pour en savoir plus sur ggplot2 : cheatsheet {ggplot2}, module 5 du parcours R sur la datavisualisation. 10.3.2 {ggplot2} pour les cartes Pour visualiser des données spatiales, ggplot propose maintenant une série de fonctions geom_sf, stat_sf et coord_sf adaptées aux dataframes de type sf. Pour les visualisations les plus simples, seule geom_sf() suffit, ggplot utilise silencieusement les fonctions de transformation stat et de coordonnées appropriées. ggreg &lt;- ggplot(COGiter::regions_geo) + geom_sf(color = &quot;white&quot;, fill = &quot;lightblue&quot;) ggreg Quatre types de calques géographiques sont utilisables : geom_sf() : pour visualiser nos objets géographiques tels quels, geom_sf_label() : pour étiqueter nos objets géographiques, geom_sf_text() : pour annoter nos objets géographiques, stat_sf_coordinates() : pour transformer des géométries complexes (lignes, polygones) en points avant de tracer le calque. geom_sf()et ses petites sœurs n’acceptent qu’une seule variable de coordonnées dans le mapping esthétique : celle de la géographie de nos données spatiales. Il n’est pas besoin de le préciser, quelque soit le nom du champ contenant les coordonnées géo s’il n’y a qu’un champ géo. Dans le cas contraire, on indique le nom de la colonne de coordonnées à utiliser dans l’aesthetic aes(geometry = mon_champ_geo). Les autres paramètres esthétiques acceptés par les fonctions de traçage de calques sf sont par exemple : colour : pour une variable qui sera représentée par la couleur (contour), fill : pour une variable qui sera représentée par la couleur de remplissage, shape : pour une variable qui sera représentée par la forme du point, size : pour une variable qui sera représentée par la taille du point ou de la ligne, alpha : pour une variable qui sera représentée par la transparence du remplissage. geom_sf_label() (étiquette) et geom_sf_text() (texte simple) acceptent en plus le paramètre label pour ajouter des étiquettes ou des annotations à notre fond de carte. Les fonctions geom_sf_text() et geom_sf_label() sont associées à la fonction de transformation stat_sf_coordinates() qui par défaut renvoie un point au centre de nos objets géographiques pour placer l’annotation textuelle (grâce à la fonction sf::st_point_on_surface()). Pour le système de coordonnées, la fonction coord_sf() va silencieusement chercher celui de nos données spatiales pour l’appliquer au graphique. Elle peut servir à définir celui qu’on l’on souhaite utiliser pour la visualisation, en spécifiant le datum (les axes représentés). coord_sf() permet également de zoomer sur la carte en spécifiant les bornes x et y de la carte, ou également de définir le titre des axes. 10.4 Faire des cartes avec {ggplot2} 10.4.1 Préparation des données Comme avec d’autres packages, la première étape consiste à préparer le jeu de données à visualiser, c’est à dire d’associer les variables à analyser à leur géographie. Ici, nous partons des données de population 2015 et les fonds de carte disponibles dans le package {COGiter}, que nous allons préparer avec {COGiter} également. pop2015_preparee &lt;- pop2015 %&gt;% # mise à jour du COG et agrégation aux différentes échelles adm cogifier(code_commune = DEPCOM, communes = TRUE, epci = TRUE, departements = TRUE, regions = TRUE, metro = FALSE) %&gt;% # on filtre le jeu de données pour ne garder que les territoires de Normandie et toutes les régions filtrer_cog(reg = &quot;28&quot;, garder_supra = &quot;&gt;=&quot;) # Aperçu du jeu de données glimpse(pop2015_preparee) Rows: 2,743 Columns: 6 $ TypeZone &lt;fct&gt; Communes, Communes, Communes, Communes, Communes, Commu… $ Zone &lt;fct&gt; &quot;Ablon&quot;, &quot;Agy&quot;, &quot;Valambray&quot;, &quot;Amayé-sur-Orne&quot;, &quot;Amayé-s… $ CodeZone &lt;fct&gt; 14001, 14003, 14005, 14006, 14007, 14009, 14011, 14012,… $ pop2015 &lt;dbl&gt; 1216, 281, 1767, 985, 218, 1414, 1935, 139, 1137, 712, … $ pop2015_a_part &lt;dbl&gt; 34, 6, 24, 18, 4, 18, 43, 2, 33, 20, 8, 5, 50, 12, 8, 2… $ pop2015_totale &lt;dbl&gt; 1250, 287, 1791, 1003, 222, 1432, 1978, 141, 1170, 732,… # Préparation des fonds carto fonds_carto_normands &lt;- filtrer_cog_geo(reg = &quot;28&quot;) #jointure du fond carto EPCI aux données EPCI de Normandie pop2015_epci_normands_geo &lt;- fonds_carto_normands$epci %&gt;% left_join(pop2015_preparee, by = c(&quot;EPCI&quot; = &quot;CodeZone&quot;)) %&gt;% # calcul des indicateurs a représenter mutate(poids_pop_a_part = pop2015_a_part / pop2015_totale * 100, densite_pop = as.numeric(pop2015 / AREA * 1000000)) 10.4.2 Les cartes choroplèthe Le premier exemple que nous allons pouvoir voir, c’est une carte choroplèthe, càd en aplat de couleur, adaptée à la représentation d’indicateurs intensifs (%, densité…), par exemple la densité de population des EPCI normands. ggplot(data = pop2015_epci_normands_geo) + geom_sf(mapping = aes(fill = densite_pop), color = &quot;white&quot;) 10.4.3 Les cartes à ronds proportionnels La fonction stat_sf_coordinates() permet d’extraire les coordonnées d’un objet ‘sf’ avant de produire le calque. Ainsi un rond proportionnel peut être attribué à un polygone. On ajoute le calque des ronds proportionnels au dessus de celui des polygones en enchainant les fonctions de traçage des calques avec le +. carte_ronds_prop &lt;- ggplot(data = pop2015_epci_normands_geo) + geom_sf() + stat_sf_coordinates(mapping = aes(size = pop2015_totale, color = poids_pop_a_part)) carte_ronds_prop 10.4.4 L’habillage simple 10.4.4.1 Titre et libellé des axes Chaque nouvel élément graphique est à ajouter sous forme de calques (layers). Pour les titres, nous utilisons la fonction labs() qui permet de donner un titre à tous les éléments possibles de l’aesthetic, ainsi que le titre (title), le sous-titre (subtitle) et le bas de page (caption). carte_ronds_prop + labs( title = &quot;Population par EPCI en Normandie&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, size = &quot;Nombre d&#39;habitants&quot;, color = &quot;Poids population\\ncomptée à part (%)&quot;, caption = &quot;Source : INSEE - RP&quot; ) A noter qu’il existe plusieurs autres façons de spécifier ces éléments par des fonctions spécifiques: ggtitle(), xlab(), ylab(), … 10.4.4.2 Légende Les fonctions guide_xx() et guides() permettent de modifier finement la légende. Les guides peuvent être spécifiées dans chaque scale_ ou dans une instruction guides. carte_ronds_prop2 &lt;- carte_ronds_prop + labs( title = &quot;Population par EPCI en Normandie&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, size = &quot;Nombre d&#39;habitants&quot;, color = &quot;Poids population\\ncomptée à part (%)&quot;, caption = &quot;Source : INSEE - RP&quot; ) + guides(color = guide_legend( direction = &quot;horizontal&quot;, order = 1, title.position = &quot;top&quot;, title.hjust = 0.5, nrow = 1, label.position = &quot;bottom&quot; )) + theme(legend.position = &quot;left&quot;) carte_ronds_prop2 10.4.4.3 Annotation Il est aussi possible de rajouter des annotations de type texte, par exemple, “texte la volée”. carte_ronds_prop2 + coord_sf(datum = 2154) + annotate(&quot;text&quot;, x = 400000, y = 6800000, label = &quot;texte à la volée&quot;, color = &quot;blue&quot;) 10.4.5 Les thèmes Pour modifier simplement la position de la légende, c’est la fonction theme() qu’il faut utiliser. theme() permet de créer des templates, c’est à dire de définir tout ce qui n’est pas lié directement aux données sur un graphique, notamment: la position, taille, couleur et police des éléments textuels la couleur des grilles primaires et secondaires du graphique Pour unifier un document, il est vivement conseillé de recourir à un thème. Il existe des thèmes prédéfinis dans ggplot que l’on peut déjà utiliser. Par exemple: theme_classic(), theme_bw(), theme_dark(), … Pour les cartes, les thèmes theme_minimal() ou theme_void() sont particulièrement indiqués. Le theme_gouv_map() de {gouvdown} est tout indiqué pour les services de l’État. Il ne gère pas les couleurs par défaut, mais tout le reste l’est. La taille des éléments de texte reste paramétrable par l’utilisateur. Voir l’aide theme_gouv_map(). carte_ronds_prop2 + theme_gouv_map(plot_title_size = 20, subtitle_size = 12) La fonction theme_set() vous permet de définir un thème par défaut pour l’ensemble de vos graphiques. theme_set(theme_gouv_map(plot_title_size = 20, subtitle_size = 12)) 10.4.6 Les scales Les fonctions scales() permettent globalement de paramétrer ou étalonner les éléments rentrés dans l’aesthetic : Si je veux un gradient de couleurs fonction d’une variable continue : quelle palette de couleurs je choisis, comment je cale mon dégradé en fonction de cette variable continue ? Si je met une variable continue en paramètre de transparence, comment je définis le minimum et maximum de cette transparence ou les valeurs que j’affiche sur l’échelle… L’ensemble des scales possibles peuvent se décrire sous la forme suivante: scale_xx_yy() ou xx peut être un des paramètres de l’aesthétic : xx description alpha transparence color couleur des lignes ou des points fill couleurs des aires linetype type de ligne (continue,pointillée,…) shape forme des points size aire des points Et yy un type de paramétrage : yy description date gérer une variable au format date reverse inverser l’axe log convertir l’échelle d’une variable continue en échelle logarithmique log10 convertir l’échelle d’une variable continue en échelle logarithmique décimale continuous gérer les variables continue discrete gérer les variables discrètes continuous_gouv utiliser les palettes de {gouvdown} (Marque Etat) pour une variable continue discrete_gouv utiliser les palettes de {gouvdown} (Marque Etat) pour une variable catégorielle gradient utiliser un gradient de 2 couleurs gradient2 utiliser un gradient divergent de 3 couleurs viridis utiliser une palette de couleur viridis brewer utiliser une palette de couleur brewer (variable discrète) distiller utiliser une palette de couleur brewer (variable continue) {gouvdown} propose des fonctions scales_xx_yy() mobilisant les palettes de couleurs à la marque Etat : La vignette graph_gouv du site de présentation de {gouvdown} propose des exemples d’utilisation des palettes pour {ggplot2}. carte_ronds_prop2 + scale_color_gouv_continuous(palette = &quot;pal_gouv_i&quot;, reverse = FALSE) {gouvdown} propose également de récupérer le code hex des couleurs de la marque Etat grâce à la fonction gouv_colors(). gouv_colors(&quot;a1&quot;) a1 &quot;#958B62&quot; On peut utiliser cette fonction pour créer une palette à partir d’un gradient de couleurs : carte_ronds_prop2 + scale_colour_gradient(low = gouv_colors(&quot;b1&quot;)[[1]], high = gouv_colors(&quot;p1&quot;)[[1]]) 10.4.6.1 Formatage spécifique Le formatage des valeurs des axes ou de la légende se fait à l’aide d’une fonction de formatage des nombres passée à l’argument ‘labels’ des fonctions scale_xx_yy() Transformation en pourcentage ; scale_color_continuous(labels = scales::percent) Ajout du symbole € ; scale_y_continuous(labels = function(x) paste(x, &quot; €&quot;)) Ajout du séparateur des milliers ; carte_ronds_prop2 + scale_color_gouv_continuous(palette = &quot;pal_gouv_i&quot;, reverse = FALSE) + scale_size_continuous(labels = function(x) format(x, big.mark = &quot; &quot;, scientific = FALSE)) 10.4.7 Exercice 3 - Carte des données dvf par quartie de Nantes Avec les résultats de l’exercice 2, produire les cartes du nombre de ventes et du prix au m2 des maisons en 2019 par quartier de Nantes. Résultats attendus : 10.4.8 Les facettes Lorsque l’on veut pouvoir réaliser une carte pour plusieurs sous-ensembles, les facettes sont alors très utiles. Il faut au préalable préparer notre jeu de données en le passant au format long avec pivot_longer() de {tidyr}. indic_epci_normands_geo_long &lt;- pop2015_epci_normands_geo %&gt;% pivot_longer(cols = c(starts_with(&quot;pop2015&quot;), densite_pop, poids_pop_a_part), names_to = &quot;indicateurs&quot;, values_to = &quot;valeurs&quot;) %&gt;% filter(!str_detect(indicateurs, &quot;pop2015&quot;)) ggplot(data = indic_epci_normands_geo_long) + geom_sf(aes(fill = valeurs), color = &quot;white&quot;) + facet_wrap(~indicateurs) + scale_fill_gouv_continuous(&quot;pal_gouv_b&quot;) Un deuxième exemple de facette sur la maille géo. fonds_carto_empiles &lt;- bind_rows( COGiter::communes_geo %&gt;% mutate(TypeZone = &quot;Communes&quot;) %&gt;% rename(CodeZone = DEPCOM), COGiter::epci_geo %&gt;% mutate(TypeZone = &quot;Epci&quot;) %&gt;% rename(CodeZone = EPCI), COGiter::departements_geo %&gt;% mutate(TypeZone = &quot;Départements&quot;) %&gt;% rename(CodeZone = DEP) ) %&gt;% inner_join(pop2015_preparee) %&gt;% mutate(densite = round(pop2015 / as.numeric(AREA) * 1000000, 0), TypeZone = fct_inorder(TypeZone)) ggplot(fonds_carto_empiles) + geom_sf(aes(fill = log(densite)), color = &quot;white&quot;, size = 0.01) + facet_wrap(~TypeZone) + scale_fill_gradient(low = gouv_colors(&quot;b1&quot;)[[1]], high = gouv_colors(&quot;p1&quot;)[[1]]) + theme_gouv_map() 10.4.9 Ajouter une barre d’échelle et la flèche du nord Le package ggspatial permet d’enrichir simplement nos cartes ggplot2 avec une barre d’échelle et la flèche du nord. Les deux fonctions qui permettent cela sont annotation_scale() et annotation_north_arrow(). L’utilisation de ces fonctions nécessitent un système de coordonnées géographiques. carte_ronds_prop2 + scale_color_gouv_continuous(palette = &quot;pal_gouv_i&quot;, reverse = FALSE) + scale_size_continuous(labels = function(x) format(x, big.mark = &quot; &quot;, scientific = FALSE)) + annotation_scale(location = &quot;br&quot;, line_width = .5) + annotation_north_arrow(location = &quot;bl&quot;, height = unit(0.7, &quot;cm&quot;), width = unit(0.7, &quot;cm&quot;)) 10.4.10 Mettre plusieurs cartes côte à côte On peut a partir d’une même carte vouloir réaliser un zoom sur une sous partie de celle-ci. coord_sf() va nous permettre de zoomer sur une carte, et cow_plot() va nous permettre d’afficher nos deux cartes côte à côte. Pour zoomer sur une carte, coord_sf() va avoir besoin des coordonnées x et y du cadre sur lequel on veut zoomer. Le plus simple pour cela est de filtrer préalablement notre spatial dataframe et de récupérer la bbox de celle-ci. Filtrons par exemple sur le Département de l’Orne. bbox_dep &lt;- fonds_carto_normands$departements %&gt;% filter(DEP == &quot;14&quot;) %&gt;% st_bbox() On peut ensuite réaliser une carte zoomée sur l’Orne normandie &lt;- carte_ronds_prop + geom_sf(data = fonds_carto_normands$departements, size = 1, color = &quot;gray10&quot;, fill = NA) + guides(color = &quot;none&quot;, size = &#39;none&#39;) calvados &lt;- normandie + coord_sf(xlim = c(bbox_dep[1], bbox_dep[3]), ylim = c(bbox_dep[2], bbox_dep[4])) + theme(panel.background = element_rect(fill = &quot;light blue&quot;)) + scale_color_gouv_continuous(palette = &quot;pal_gouv_i&quot;, reverse = FALSE) + scale_size_continuous(labels = function(x) format(x, big.mark = &quot; &quot;, scientific = FALSE)) + labs(title = &quot;Population par EPCI en Normandie&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, size = &quot;Nombre d&#39;habitants&quot;, color = &quot;Poids population\\ncomptée à part (%)&quot;, caption = &quot;Source : INSEE - RP&quot;) calvados On peut utiliser ensuite le package {cowplot} et sa fonction plot_grid() pour afficher nos cartes côte à côte. La fonction plot_grid() qui permet de disposer n graphes sur i colonnes et j lignes. Il faut jouer sur les largeurs relatives pour que les deux cartes s’agencent bien. plot_grid(calvados, normandie, rel_widths = c(1, 2)) 10.4.11 Exporter sa carte ggplot contient une fonction ggsave() qui permet d’exporter nos graphiques ou cartes dans les formats suivants : eps, ps, tex (pictex), pdf, jpeg, tiff, png, bmp, svg or wmf. p &lt;- carte_ronds_prop2 + scale_color_gouv_continuous(palette = &quot;pal_gouv_i&quot;, reverse = FALSE) + scale_size_continuous(labels = function(x) format(x, big.mark = &quot; &quot;, scientific = FALSE)) ggsave(&quot;pic/pop_epci_2015_normandie.svg&quot;, p, width = 12, height = 5) 10.4.12 Exercice 4 : Assemblage de cartes sur dvf A partir des données dvf 2014 et 2017 de la région Pays de la Loire contenues dans le package {variousdata} et les fonds de carte de {COGiter}, produire : une carte régionale à l’EPCI comprenant : un dégrade de couleur sur l’évolution des prix au m2 des maisons entre 2014 et 2017, un rond sur le volume des prix au m2 des maisons, un zoom sur les communes des principaux EPCI, c’est à dire une carte à la commune par EPCI de type Métropole (ME) ou Communauté urbaine (CU). Puis, assembler ces différentes cartes sur un même graphique. Il faut comme toujours procéder par étape. Etape 1 : Calcul de l’évolution des prix et du nombre de ventes A l’EPCI A la commune Intégration des données calculées aux fonds de carte Etape 2 : Datavisualisation Carte à l’EPCI de la région Zooms à la commune Assemblage 10.5 Faire des cartes avec {mapfactory} {mapfactory} facilite la création de cartes statistiques sur les territoires administratifs français, sur la base des packages {COGiter}, {gouvdown} et {ggplot2}. Il s’installe depuis la forge gitlab du pôle ministériel : remotes::install_gitlab(repo = &quot;dreal-pdl/csd/mapfactory&quot;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) Il crée des cartes régionales de visualisation d’indicateurs statistiques préparés par {COGiter}, aux maille départements, EPCI ou communes. pop2015_prepa_nat &lt;- pop2015 %&gt;% cogifier() %&gt;% mutate(poids_pop_a_part = pop2015_a_part / pop2015_totale * 100) creer_carte_communes_prop(data = pop2015_prepa_nat, code_region = &quot;02&quot;, indicateur = pop2015, carto = fond_carto(&quot;Martinique&quot;, ombre = 0), espace = &quot;\\u202f&quot;, palette = &quot;pal_gouv_o&quot;, titre = &quot;Population par commune&quot;, sous_titre = &quot;En 2015&quot;, bas_de_page = &quot;INSEE - RP&quot;, decimales = 0, suffixe = &quot; hab&quot;, nclass = 4, method = &quot;quantile&quot;) Les fonctions principales sont : creer_carte_categorie_epci(), creer_carte_categorie_communes() : pour créer une carte régionale de visualisation d’un indicateur catégoriel ; creer_carte_epci(), creer_carte_communes() pour créer une carte régionale choroplèthe ; creer_carte_epci_prop(), creer_carte_communes_prop() pour créer une carte régionale de visualisation d’un indicateur en rond proportionnel. Toutes ces fonctions sont des cas particulier de la fonction creer_carte() : creer_carte(data = pop2015_prepa_nat, code_region = &quot;28&quot;, indicateur = poids_pop_a_part, maillage = &quot;Département&quot;, carto = fond_carto(&quot;Normandie&quot;), titre = &quot;Proportion de la population comptée à part&quot;, sous_titre = &quot;En 2015&quot;, bas_de_page = &quot;INSEE - RP&quot;, decimales = 1, pourcent = TRUE, palette = &quot;pal_gouv_b&quot;, espace = &quot;\\u202f&quot; ) Il est nécessaire de partir d’un jeu de données national pour utiliser ce package, car les valeurs des territoires voisins sont requises pour la mise en page. "],["cartogramm.html", "Chapitre 11 Créer des cartogrammes 11.1 Cartogramme d’aires contigues 11.2 Cartogramme d’aire non contigue 11.3 Cartogramme de Dorling", " Chapitre 11 Créer des cartogrammes Un cartogramme est une carte pour laquelle une variable continue définit la surface des territoires représentés. La géométrie de l’espace de la carte est donc déformée afin de se conformer aux informations relatives à cette variable. Les fonctions du package {cartogramm} permettent de réaliser l’opération de déformation attendue. La sortie de ces fonctions est un spatial dataframe avec une nouvelle géométrie. On peut ensuite utiliser cette nouvelle géométrie pour la visualiser avec tout package de cartographie. Dans ce chapitre nous allons utiliser les packages suivants. # CRAN library(cartogram) library(tidyverse) # Github library(COGiter) # remotes::install_github(&quot;MaelTheuliere/COGiter&quot;) library(gouvdown) # remotes::install_github(&quot;spyrales/gouvdown&quot;) Les données utilisées sont issues de {COGiter} : pop2015_dep_geo &lt;- pop2015 %&gt;% # mise à jour du COG et agrégation aux différentes échelles adm cogifier(code_commune = DEPCOM, communes = FALSE, epci = FALSE, departements = TRUE, regions = FALSE, metro = FALSE) %&gt;% inner_join(COGiter::departements_geo, ., by = c(&quot;DEP&quot; = &quot;CodeZone&quot;)) 11.1 Cartogramme d’aires contigues On définit la couche à partir de la variable d’une table, ici la population par département. La fonction cartogram_cont() permet de produire la déformation attendue. pop2015_dep_cont &lt;- cartogram_cont(pop2015_dep_geo, &quot;pop2015&quot;) On peut ensuite utiliser {ggplot2} pour cartographier cette couche. pop2015_dep_cont %&gt;% ggplot() + geom_sf(aes(fill = pop2015 / 1000), color=&quot;white&quot;, size=.2) + labs( title = &quot;Population par département&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Milliers d&#39;habitants&quot;, caption = &quot;Source : INSEE - RP&quot; ) + scale_fill_gouv_continuous(palette = &quot;pal_gouv_o&quot;, reverse = TRUE, labels = ~format(.x, big.mark = &quot; &quot;, scientific = FALSE)) 11.2 Cartogramme d’aire non contigue La fonction cartogram_ncont() permet de définir la déformation attendue. pop2015_dep_ncont &lt;- cartogram_ncont(pop2015_dep_geo, &quot;pop2015&quot;) ggplot(COGiter::departements_geo) + geom_sf(color = &quot;grey&quot;, size=.4) + geom_sf(data = pop2015_dep_ncont, aes(fill = pop2015 / 1000), color = &quot;white&quot;, size = .4) + labs( title = &quot;Population par département&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, fill = &quot;Milliers d&#39;habitants&quot;, caption = &quot;Source : INSEE - RP&quot; ) + scale_fill_gouv_continuous(palette = &quot;pal_gouv_o&quot;, reverse = TRUE, labels = ~format(.x, big.mark = &quot; &quot;, scientific = FALSE)) 11.3 Cartogramme de Dorling Le cartogramme de Dorling est une représentation spatiale qui vise à remplacer les polygones par des cercles proportionnels à une variable donnée, en respectant au maximum la position spatiale des polygones. La fonction cartogram_dorling() permet de définir la géométrie attendue. On va ici réaliser un cartogramme de dorling sur la densité de population par département 2015. gdp_dorling &lt;- pop2015_dep_geo %&gt;% filter(!is.na(AREA)) %&gt;% mutate(densite = pop2015 / as.numeric(AREA) * 1000000) %&gt;% left_join(departements, by = &quot;DEP&quot;) %&gt;% cartogram_dorling(&quot;densite&quot;) gdp_dorling %&gt;% ggplot() + geom_sf(aes(fill = REG)) + labs( title = &quot;Population par département&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, caption = &quot;Source : INSEE - RP&quot;) + scale_fill_gouv_discrete(palette = &quot;pal_gouv_qual1&quot;, guide = &quot;none&quot;) "],["creer-des-cartes-pour-le-web.html", "Chapitre 12 Créer des cartes pour le web 12.1 Les cartes Leaflet 12.2 Les cartes ggplot 12.3 Les cartes {mapfactory} 12.4 Exporter une sortie html 12.5 Exercice 5 : cartes DVF pour le web", " Chapitre 12 Créer des cartes pour le web 12.1 Les cartes Leaflet {leaflet} est une bibliothèque javascript de cartographie en ligne. R permet de produire des cartes en exploitant cette bibliothèque. La limitation de {leaflet} est qu’il ne permet de visualiser que des données en projection WGS84. Dans ce chapitre, nous utiliserons les packages suivants # CRAN library(htmltools) library(htmlwidgets) library(leaflet) library(sf) library(tidyverse) # Github library(COGiter) # remotes::install_github(&quot;MaelTheuliere/COGiter&quot;) library(ggiraph) # Gitlab-forge library(mapfactory) # remotes::install_gitlab(&quot;dreal-pdl/csd/mapfactory&quot;, host = &quot;gitlab-forge.din.developpement-durable.gouv.fr&quot;) Les données utilisées sont issues de {COGiter}. 12.1.1 Carte choroplète Ci-dessous un exemple avancé de carte choroplète avec {leaflet}. Définition des données de départ : pop2015_dep_geo &lt;- pop2015 %&gt;% # mise à jour du COG et agrégation à l&#39;échelle départementale cogifier(code_commune = DEPCOM, communes = FALSE, epci = FALSE, departements = TRUE, regions = FALSE, metro = FALSE) %&gt;% inner_join(COGiter::departements_geo, ., by = c(&quot;DEP&quot; = &quot;CodeZone&quot;)) %&gt;% mutate(densite = pop2015 / as.numeric(AREA) * 1000000) %&gt;% filter(substr(DEP, 1, 2) != &quot;97&quot;) glimpse(pop2015_dep_geo) Rows: 96 Columns: 9 $ DEP &lt;fct&gt; 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14,… $ AREA [m^2] 5774236437 [m^2], 7418547459 [m^2], 7365661052 [m^2], 6… $ geometry &lt;GEOMETRY [m]&gt; POLYGON ((864753.7 6525714,..., POLYGON ((7311… $ TypeZone &lt;fct&gt; Départements, Départements, Départements, Départements,… $ Zone &lt;fct&gt; Ain, Aisne, Allier, Alpes-de-Haute-Provence, Hautes-Alp… $ pop2015 &lt;dbl&gt; 631877, 538659, 341613, 161799, 140916, 1082440, 324209… $ pop2015_a_part &lt;dbl&gt; 17135, 13870, 10013, 4836, 5144, 15116, 9572, 7860, 540… $ pop2015_totale &lt;dbl&gt; 649012, 552529, 351626, 166635, 146060, 1097556, 333781… $ densite &lt;dbl&gt; 109.43040, 72.60977, 46.37914, 23.13337, 24.78718, 252.… Transformation de la projection car leaflet ne connait que le WGS 84 : pop2015_dep_geo &lt;- st_transform(pop2015_dep_geo, crs=(&quot;+proj=longlat +datum=WGS84 +no_defs&quot;)) Discrétisation de la variable d’intérêt : bornes &lt;- quantile(pop2015_dep_geo$densite, na.rm = TRUE) Création d’une palette de couleurs associée : {leaflet} intègre une fonction colorBin() qui permet d’associer à un vecteur de valeurs numériques un vecteur de couleurs en fonction d’une palette et d’un vecteur de bornes. pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = pop2015_dep_geo$densite, bins = bornes) Création d’étiquettes popover, à afficher en surbrillance au passage de la souris sur la carte : popover &lt;- sprintf(&quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%.1f habitants par km² en 2015&quot;, pop2015_dep_geo$Zone, pop2015_dep_geo$densite) %&gt;% lapply(htmltools::HTML) Réalisation de la carte : La fonction addPolygons() permet de créer la carte choroplète. La fonction addProviderTiles() permet de rajouter un fond cartographique parmis les couches fournies par leaflet. leaflet(pop2015_dep_geo) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addPolygons(data = pop2015_dep_geo, fillColor = ~pal(densite), weight = 2, opacity = 1, color = &quot;white&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.7, highlight = highlightOptions( weight = 5, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.7, bringToFront = TRUE), label = popover, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;)) 12.1.2 Carte à ronds proportionnels Pour réaliser des ronds proportionnels, il va faut partir des centroïdes de nos polygones. On cherche cette fois à représenter les populations 2015. Création de la table en entrée : dep_centr &lt;- st_centroid(pop2015_dep_geo) Discrétisation de la variable d’intérêt : bornes &lt;- quantile(dep_centr$pop2015 / 1000, na.rm = TRUE) Création d’une palette de couleurs associée : pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = dep_centr$pop2015 / 1000, bins = bornes) Création d’un label ad-hoc à afficher en surbrillance au passage de la souris sur la carte : popover &lt;- sprintf(&quot;&lt;strong&gt;%s&lt;/strong&gt;&lt;br/&gt;%.1f milliers habitants en 2015&quot;, dep_centr$Zone, dep_centr$pop2015 / 1000) %&gt;% lapply(htmltools::HTML) Création de la carte : carte_rond_proportionnel &lt;- leaflet(dep_centr) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addCircles(data = dep_centr, fillColor = ~pal(pop2015 / 1000), radius = ~2500*log(pop2015), weight = 2, opacity = 1, color = &quot;gray&quot;, dashArray = &quot;3&quot;, fillOpacity = 0.6, highlight = highlightOptions( weight = 5, color = &quot;#666&quot;, dashArray = &quot;&quot;, fillOpacity = 0.98, bringToFront = TRUE), label = popover, labelOptions = labelOptions( style = list(&quot;font-weight&quot; = &quot;normal&quot;, padding = &quot;3px 8px&quot;), textsize = &quot;15px&quot;, direction = &quot;auto&quot;)) %&gt;% addLegend(&quot;bottomright&quot;, pal = pal, values = ~pop2015, title = &quot;Nombre d&#39;habitants en 2015 - INSEE - RP&quot;, opacity = 1) carte_rond_proportionnel 12.2 Les cartes ggplot Les cartes créées par {ggplot2}, comme tous les autres graphiques produits avec ggplot d’ailleurs, peuvent être rendues dynamiques grâce à {ggiraph} développé par David Gohel. Ce package permet l’ajout d’info-bulles, des effets de survol et d’ajouter des actions JavaScript aux graphiques. L’interactivité est s’applique aux géométries ggplot, aux légendes et aux éléments de thème, grâce aux paramètres esthétiques suivants : tooltip: info-bulles à afficher lorsque la souris se trouve sur les éléments ; onclick: fonction JavaScript à exécuter lorsque les éléments sont cliqués ; data_id: id à associer aux éléments (utilisé pour les actions de survol et de clic). Les choses que vous devez savoir pour créer un graphique interactif : Au lieu d’utiliser geom_sf(), utilisez geom_sf_interactive(), au lieu d’utiliser geom_sf_label(), utilisez geom_sf_label_interactive()… Fournissez au moins une des esthétiques tooltip, data_id and onclick pour créer des éléments interactifs. Appelez la fonction girafe avec l’objet ggplot afin que le graphique soit traduit en un graphique web interactif. On reprend notre carte ggplot normande en ronds proportionnels : systemfonts::register_font(name = &quot;Marianne light&quot;, system.file(&quot;resources/fonts/marianne/truetype/Marianne-Light.ttf&quot;, package = &quot;gouvdown.fonts&quot;)) carte_ronds_prop_dyn &lt;- ggplot(data = pop2015_epci_normands_geo) + geom_sf_interactive(aes(tooltip = Zone)) + geom_sf_interactive(data = st_point_on_surface(pop2015_epci_normands_geo), mapping = aes(size = pop2015_totale, color = poids_pop_a_part, tooltip = paste0(Zone, &quot;\\n&quot;, format_fr_nb(pop2015_totale, dec = 0, big_mark = &quot; &quot;), &quot; hab.\\ndont &quot;, format_fr_nb(poids_pop_a_part, dec = 1, big_mark = &quot; &quot;), &quot; % comptés à part&quot;))) + labs( title = &quot;Population par EPCI en Normandie&quot;, subtitle = &quot;En 2015&quot;, x = &quot;&quot;, y = &quot;&quot;, size = &quot;Nombre d&#39;habitants&quot;, color = &quot;Poids population\\ncomptée à part (%)&quot;, caption = &quot;Source : INSEE - RP&quot; ) + theme_gouv_map(plot_title_size = 20, subtitle_size = 12) + scale_color_gouv_continuous(palette = &quot;pal_gouv_i&quot;, reverse = TRUE) + scale_size_continuous(labels = function(x) format(x, big.mark = &quot; &quot;, scientific = FALSE)) + annotation_north_arrow(location = &quot;bl&quot;, height = unit(0.7, &quot;cm&quot;), width = unit(0.7, &quot;cm&quot;)) girafe(ggobj = carte_ronds_prop_dyn) 12.3 Les cartes {mapfactory} {mapfactory} s’appuie sur {ggiraph} pour rendre ses cartes dynamiques. Les arguments de la fonction creer_carte() en rapport avec l’interactivité sont interactive TRUE si on veut une carte html interactive. popover Chaîné de texte désignant le contenu de l’info-bulles. Par défaut, L’étiquette qui s’affiche au survol contient “nom du territoire : valeur de l’indicateur et suffixe”, obtenu a partir de “.data\\(nom_ter : .data\\)valeur”. indicateur_popover Un nom d’indicateur présent dans data (sans quote) a mobiliser pour le popover. Utiliser .data$valeur_popover au niveau du parametre popover pour afficher les valeurs de cet indicateur, par exemple .data$nom_ter : .data$valeur_popover unites. creer_carte(data = cogifier(pop2015), code_region = &quot;52&quot;, indicateur = pop2015, espace = &quot; &quot;, interactive = TRUE, type_viz = &quot;proportionnel&quot;, maillage = &quot;Départements&quot;) 12.4 Exporter une sortie html La fonction saveWidget() permet d’exporter une sortie d’un HTML Widget en fichier HTML. saveWidget(widget = girafe(ggobj = carte_ronds_prop_dyn), file = &quot;part_pop_a_part_epci_normandie.html&quot;) 12.5 Exercice 5 : cartes DVF pour le web Adapter la carte régionale à l’EPCI de l’exercice 4, pour le web : au survol d’un EPCI, afficher son nom, le prix au m2 et son évolution 2014-2017, au survol du rond d’un EPCI, afficher son nom, le nb de ventes 2017. "],["osm.html", "Chapitre 13 Focus sur OpenStreetMap 13.1 Afficher une carte interactive 13.2 Importer les fonds de carte pour ggplot 13.3 Importer des données OSM 13.4 Calculer des itinéraires", " Chapitre 13 Focus sur OpenStreetMap OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de données géographiques libre à l’échelle mondiale. OpenStreetMap vous permet de voir, modifier et d’utiliser des données géographiques du monde entier. Conditions d’utilisation OpenStreetMap est en données ouvertes : vous êtes libre de l’utiliser pour n’importe quel but tant que vous créditez OpenStreetMap et ses contributeurs. Si vous modifiez ou vous appuyez sur les données d’une façon quelconque, vous pouvez distribuer le résultat seulement suivant la même licence. (…) Contributeurs (…) Nos contributeurs incluent des cartographes enthousiastes, des professionnels du SIG, des ingénieurs qui font fonctionner les serveurs d’OSM, des humanitaires cartographiant les zones dévastées par une catastrophe et beaucoup d’autres. (…) A propos d’OpenStreetMap R propose une série de packages qui se basent sur OpenStreetMap. Dans ce chapitre nous allons utiliser les packages suivants : # packages CRAN library(ggspatial) library(leaflet) library(mapview) library(osmdata) library(osmextract) library(osrm) library(sf) library(tidyverse) # packages Github library(COGiter) # remotes::install_github(&quot;MaelTheuliere/COGiter&quot;) library(gouvdown) # remotes::install_github(&quot;spyrales/gouvdown&quot;) # Données load(&quot;extdata/sirene.RData&quot;) load(&quot;extdata/admin_express.RData&quot;) 13.1 Afficher une carte interactive Les deux principaux packages qui permettent d’afficher une carte interactive basée sur OSM sont {leaflet} et {mapview}, vus précédemment. {leaflet} utilise la libraire javascript Leaflet pour créer des cartes interactives. Site web de {leaflet} : Leaflet for R {mapview} s’appuie sur {leaflet} pour créer des cartes interactives, son utilisation est plus simple car les instructions sont très concises. Site web de {mapview}: mapview 13.2 Importer les fonds de carte pour ggplot Le package {ggspatial} permet de télécharger et d’afficher des fonds de cartes raster issu d’OSM grâce à la fonction annotation_map_tile(). boul_44 &lt;- filter(sirene44, APET700 == &quot;1071C&quot;) %&gt;% select(SIREN, NOMEN_LONG) ggplot(boul_44) + annotation_map_tile(type = &quot;osm&quot;) + geom_sf() + theme_gouv_map() | | | 0% | |================== | 25% | |=================================== | 50% | |==================================================== | 75% | |======================================================================| 100% 13.3 Importer des données OSM 13.3.1 {osmdata} Le package {osmdata} permet d’extraire des données vectorielles depuis OSM en utilisant l’API Overpass turbo. Site web du package osmdata On développe ici un exemple dans lequel on extrait les pistes cyclables sur Nantes Métropole. On commence par définir la bbox de requête, au CRS 4326. # Sélection de l&#39;emprise de la requête, nantes_metro &lt;- epci_geo %&gt;% filter(NOM_EPCI == &quot;Nantes Métropole&quot;) %&gt;% st_transform(4326) # Définition d&#39;une bounding box de requête q &lt;- opq(bbox = st_bbox(nantes_metro, 4326)) # Extraction des pistes cyclables req &lt;- add_osm_feature(opq = q, key = &#39;highway&#39;, value = &quot;cycleway&quot;) res &lt;- osmdata_sf(req) # Reduction du resultats # (les points composant les polygones sont supprimés) res &lt;- unique_osmdata(res)$osm_lines mapview(res) L’API comprend des limites : l’emprise de la surface d’interrogation et le nombre de requêtes envoyées par jour ne sont pas infinis. Site web d’{osmdata} : osmdata 13.3.2 osmextract Le package {osmextract} permet d’extraire des données depuis une base de données OSM directement, sans limitation. Ce package permet de travailler sur des volumes de données très importants. Voici un exemple d’usage d’{osmextract}, toujours sur les pistes cyclables, qui va de la récupération des données au calcul d’indicateurs par commune. https://gitlab-forge.din.developpement-durable.gouv.fr/dreal-pdl/csd/sgbd_datamart/-/blob/master/data-raw/chargement_pistes_cyclables_osm.R Site web d’{osmextract} : osmextract 13.4 Calculer des itinéraires Le package {osrm} sert d’interface entre R et le service de calcul d’itinéraire OSRM . Ce package permet de calculer des matrices de temps et de distances, des itinéraires routiers, des isochrones. Le package utilise par défaut le serveur de démonstration d’OSRM. En cas d’utilisation intensive il est fortement recommandé d’utiliser sa propre instance d’OSRM (avec Docker). 13.4.1 Calcul d’un itinéraire La fonction osrmRoute() permet de calculer des itinéraires. On l’utilise ici pour un trajet du CVRH de Nantes à la gare SNCF. Le paramètre osrm.profile sert à indiquer le profil du voyageur : véhiculé (“car”), cycliste (“bike”) ou piéton (“foot”). Par défaut elle renvoie un objet géo, correspondant à l’itinéraire calculé. mes_adresses &lt;- data.frame(services = c(&quot;CVRH Nantes&quot;, &quot;Gare Nord Nantes&quot;), lat = c(47.22542, 47.217777), long = c(-1.574013, -1.542315)) %&gt;% st_as_sf(coords = c(&quot;long&quot;, &quot;lat&quot;), crs = 4326) %&gt;% st_transform(3857) mapview(mes_adresses) trajet &lt;- osrmRoute(src = mes_adresses[1,], dst = mes_adresses[2,], osrm.profile = &quot;bike&quot;) mapview(list(mes_adresses, trajet)) osrmRoute(src = mes_adresses[1,], dst = mes_adresses[2,], overview = FALSE, osrm.profile = &quot;bike&quot;) duration distance 15.95 3.34 Le paramètre overview lorsqu’il est mis à FALSE, permet de récupérer la durée et la longueur de l’itinéraire. 13.4.2 Calcul d’une matrice de temps La fonction osrmTable() permet de calculer des matrices de distances ou de temps par la route. Dans cet exemple nous calculons une matrice de temps entre les 2 adresses et les restaurants de Nantes Métropole à pied. Préparons nos données : load(&quot;extdata/sirene.RData&quot;) emprise_nantes &lt;- COGiter::communes_geo %&gt;% filter(DEPCOM == &quot;44109&quot;) %&gt;% st_transform(2154) restaurants_nantes &lt;- filter(sirene44, APET700 == &quot;5610A&quot;) %&gt;% st_transform(2154) %&gt;% st_filter(emprise_nantes) %&gt;% st_transform(4326) Calculons la matrice de distance entre les 2 adresses et les restaurants de Nantes : mat &lt;- osrmTable(src = mes_adresses, dst = restaurants_nantes, osrm.profile = &quot;foot&quot;) mat$durations[,1:5] Quelle adresse possède une meilleurs accessibilité en temps aux restaurants ? boxplot(t(mat$durations), cex.axis = .7) "],["a-propos.html", "Chapitre 14 A propos de ce document Code source Inspiration Licence Session info", " Chapitre 14 A propos de ce document Code source Le code source de ce document se trouve à l’adresse suivante : https://github.com/MTES-MCT/parcours_r_module_analyse_spatiale Il est généré par l’excellente extension bookdown de Yihui Xie. Inspiration Ce document est largement inspiré des supports suivants : Geocomputation with R de Robin Lovelace, Jakub Nowosad et Jannes Muenchow ; Géomatique avec R de Timothée Giraud &amp; Hugues Pecout le contenu du module Datavisualisation : produire des graphiques, des cartes et des tableaux avec R, de Murielle Lethrones et Maël THEULIERE, du parcours de formation à R du Ministère de la Transition écologique et solidaire et du Ministère de la Cohésion des territoires et des Relations avec les collectivités territoriales pour la partie rappel sur les dataviz et la réalisation de cartes. Licence Ce document est mise à disposition selon les termes de la Licence Ouverte2.0. Session info setting value version R version 4.2.1 (2022-06-23) os Ubuntu 20.04.5 LTS system x86_64, linux-gnu ui X11 language (EN) collate en_US.UTF-8 ctype en_US.UTF-8 tz Etc/UTC date 2024-08-26 pandoc 2.19.2 @ /usr/local/bin/ (via rmarkdown) package ondiskversion source banR 0.2.2 Github (joelgombin/banR@2234b55419b6e93760aa50c97efaa2350e9720d6) CARTElette 1.0.3 Github (antuki/CARTElette@aab78ee9874362d1af7c3b1ea17e9632e982d0ae) cartogram 0.3.0 RSPM (R 4.2.0) cowplot 1.1.3 RSPM (R 4.2.0) datalibaba 0.0.0.9007 xgit (https://gitlab-forge.din.developpement-durable.gouv.fr/dreal-pdl/csd/datalibaba.git@77b33a609c2b36d22e43615345ce60bf86eaa902) dplyr 1.1.4 RSPM (R 4.2.0) DT 0.33 RSPM (R 4.2.0) forcats 1.0.0 RSPM (R 4.2.0) ggiraph 0.8.10 RSPM (R 4.2.0) ggplot2 3.5.1 RSPM (R 4.2.0) ggspatial 1.1.9 RSPM (R 4.2.0) glue 1.7.0 RSPM (R 4.2.0) gouvdown 0.0.0.9001 Github (spyrales/gouvdown@1eeefa34734f599f36b713c81e523d88aa2ecafe) gouvdown.fonts 0.0.1 Github (spyrales/gouvdown.fonts@d40dfe7cd22fbe9f476b7f480b6cc2a263c95264) htmltools 0.5.8.1 RSPM (R 4.2.0) htmlwidgets 1.6.4 RSPM (R 4.2.0) httr 1.4.7 RSPM (R 4.2.0) jsonlite 1.8.8 RSPM (R 4.2.0) kableExtra 1.4.0 RSPM (R 4.2.0) knitr 1.48 RSPM (R 4.2.0) leaflet 2.2.2 RSPM (R 4.2.0) lubridate 1.9.3 RSPM (R 4.2.0) mapedit 0.6.0 RSPM (R 4.2.0) mapfactory 0.0.0.9005 xgit (https://gitlab-forge.din.developpement-durable.gouv.fr/dreal-pdl/csd/mapfactory.git@64a685fa704e6ad60eb0ee6e18a20ae247ce9c24) mapview 2.11.2 RSPM (R 4.2.0) osmdata 0.2.5 RSPM (R 4.2.0) osmextract 0.5.1 RSPM (R 4.2.0) osrm 4.2.0 RSPM (R 4.2.0) purrr 1.0.2 RSPM (R 4.2.0) readr 2.1.5 RSPM (R 4.2.0) remotes 2.5.0 RSPM (R 4.2.0) rmapshaper 0.5.0 RSPM (R 4.2.0) RPostgres 1.4.7 RSPM (R 4.2.0) savoirfR 0.0.0.9009 Github (MTES-MCT/savoirfR@8c09f173d09b5428647a6fe6af84516f3057450e) scales 1.3.0 RSPM (R 4.2.0) sf 1.0.16 RSPM (R 4.2.0) spData 2.3.1 RSPM (R 4.2.0) stringr 1.5.1 RSPM (R 4.2.0) tibble 3.2.1 RSPM (R 4.2.0) tidyr 1.3.1 RSPM (R 4.2.0) tidyverse 2.0.0 RSPM (R 4.2.0) tmap 3.3.4 RSPM (R 4.2.0) tmaptools 3.1.1 RSPM (R 4.2.1) variousdata 0.0.0.9000 Github (MaelTheuliere/variousdata@532e601d8ca63581a5c89e3c736523f69728da9a) viridis 0.6.5 RSPM (R 4.2.0) viridisLite 0.4.2 RSPM (R 4.2.0) "],["creer-des-cartes-avec-tmap.html", "Chapitre 15 Annexe : créer des cartes avec tmap 15.1 Fonction tm_shape() 15.2 Exemple de carte choroplèthe 15.3 Exemple de carte à ronds proportionnels 15.4 Discretisation 15.5 Exemples de cartes avec facet 15.6 Gestion des palettes 15.7 La mise en page 15.8 Assembler plusieurs cartes 15.9 tmap pour le web 15.10 Export d’une carte", " Chapitre 15 Annexe : créer des cartes avec tmap tmap est un package dédié à la réalisation de cartes sous R. La syntaxe est très proche de ggplot, avec l’opérateur + pour enchaîner les options. L’équivalent des geom_xx() dans tmap sont les fonctions suivantes : tm_lines() : afficher des lignes tm_polygons() : afficher des polygones tm_raster() : afficher un raster tm_bubbles() : afficher des ronds proportionnels tm_markers() : afficher des marqueurs tm_text() : afficher du texte Les différences avec ggplot2 : Les variables s’appellent dans des cotes \"\" ; Le facetting peut se faire sur des données au format large (une carte par colonne et non une carte par modalité d’une variable) ; Les fonctions tm_xx() incluent la définition des classes (nombre de classe, définition des classes et des palettes) sans passer par une fonction scale() dont l’équivalent n’existe pas. La mise en page se définit avec la fonction tm_layout(), la légende avec tm_legend() Dans ce chapitre nous allons utiliser les packages suivants # CRAN library(sf) library(tidyverse) library(tmap) library(tmaptools) library(viridis) # Github library(variousdata) # remotes::install_github(&quot;MaelTheuliere/variousdata&quot;) 15.1 Fonction tm_shape() Pour charger une donnée géométrique à visualiser avec {tmap}, il faut utiliser la fonction tm_shape(). tm_shape() initie la création de la carte, en fixant plusieurs options de base de notre carte : la projection, la bbox, un facteur de simplification… data(&quot;World&quot;) wgs_84 &lt;- tm_shape(World, projection = st_crs(4326)) + tm_polygons() + tm_layout(&quot;Le monde en projection WGS84&quot;, inner.margins=c(0,0,.1,0), title.size=.8) robin &lt;- tm_shape(World, projection = st_crs(&quot;+proj=wintri&quot;)) + tm_polygons() + tm_layout(&quot;Le monde en projection Winkel-Tripel&quot;, inner.margins=c(0,0,.1,0), title.size=.8) 15.2 Exemple de carte choroplèthe La fonction tm_polygons() permet de faire des cartes choroplèthe. Nous partons ici des banque d’indicateurs internationaux tenue par l’ONU sur les Objectifs de développement durable, diffusée dans le package {variousdata}. 15.2.1 Préparation des données On prépare les données en associant les indicateurs à leur géographie. sdg_indicators_sf &lt;- World %&gt;% left_join(sdg_indicators, by = c(&quot;iso_a3&quot;, &quot;continent&quot;)) %&gt;% st_transform(crs = st_crs(3857)) 15.2.2 Cartographie On réalise une analyse thématique de la variable sh_sta_mmr qui représente le taux de mortalité de la mère à la naissance (Maternal mortality ratio). sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape() + tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;) + tm_borders(&quot;white&quot;, lwd = .5) 15.3 Exemple de carte à ronds proportionnels La fonction tm_bubble() permet de faire des cartes à ronds proportionnels. L’utilisation de tm_polygons() permet sans lui spécifier de paramètre d’afficher les frontières des pays avec une couleur de remplissage par défaut. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape() + tm_polygons() + tm_bubbles(size = &quot;sh_sta_mmr&quot;, col = &quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;) 15.4 Discretisation Pour définir comment notre variable continue va être discrétisée, deux méthodes : discrétiser à la main et indiquer les valeurs limites dans l’option breaks de notre tm_xx utiliser l’option style des tm_xx qui permettent de choisir un algorithme de discrétisation. La méthode de jenks par exemple permet de maximiser la variance interclasse. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style=&quot;jenks&quot;) L’option n = permet d’imposer un nombre de classes à la méthode utilisée. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape() + tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;, n = 3) 15.5 Exemples de cartes avec facet tm_facets() permet de réaliser des cartes à facette avec la même logique que celle de ggplot2. sdg_indicators_sf %&gt;% filter(timeperiod %in% c(&quot;2000&quot;, &quot;2005&quot;, &quot;2010&quot;, &quot;2015&quot;)) %&gt;% tm_shape() + tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;) + tm_facets(&quot;timeperiod&quot;) 15.6 Gestion des palettes La fonction tmaptools::palette_explorer() permet d’accéder à une interface très simple de définition d’une palette de couleur à partir des palette brewer. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape() + tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;, palette = get_brewer_pal(&quot;OrRd&quot;, n = 5, contrast = c(0.2, 1), plot = FALSE)) On peut également utiliser n’importe qu’elle palette, par exemple la palette viridis, mais sans l’interface proposée par palette_explorer() : sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;, palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;)) 15.7 La mise en page tm_layout() permet de contrôler les polices, la légende, les marges, les couleurs. L’option design.mode = TRUE permet de voir visuellement les marges, la position de la légende. Le titre de la légende ne se définit pas dans tm_layout() mais dans tm_polygons(). L’option title de ces fonctions est l’équivalent d’un libellé de la variable mise dans l’aesthetic. On peut rajouter une barre d’échelle et la flèche du nord avec tm_scale_bar() et tm_compass(). sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;,textNA = &quot;Valeur manquante&quot;, style = &quot;jenks&quot;, palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;), title = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;)+ tm_layout(main.title = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size = 1.2, bg.color = &quot;skyblue&quot;, legend.position = c(&quot;left&quot;,&quot;bottom&quot;), legend.bg.color = &quot;white&quot;, legend.bg.alpha = .4, legend.outside = FALSE, main.title.position = &quot;center&quot;, frame = FALSE)+ tm_scale_bar(position = c(&quot;center&quot;,&quot;bottom&quot;))+ tm_compass(position = c(&quot;right&quot;,&quot;top&quot;)) Avec les cartes en ronds proportionnels, on peut spécifier un titre pour la couleur et la taille du rond. sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons()+ tm_bubbles(size=&quot;sh_sta_mmr&quot;,col=&quot;sh_sta_mmr&quot;,style=&quot;jenks&quot;, palette=viridis(5, alpha = 1, begin = 0, end = 1, direction = 1, option = &quot;D&quot;), title.col=&quot;&quot;, title.size=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot;)+ tm_layout(main.title=&quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size=1.2, outer.margins=c(0,0,0,0), legend.position=c(&quot;left&quot;,&quot;bottom&quot;), legend.outside = FALSE, main.title.position = &quot;center&quot;, inner.margins = c(0, 0, 0, 0), frame = FALSE)+ tm_scale_bar(position = c(&quot;center&quot;,&quot;bottom&quot;))+ tm_compass(position = c(&quot;right&quot;,&quot;top&quot;)) 15.8 Assembler plusieurs cartes tmap_arrange() permet d’assembler plusieurs cartes ensemble. La limite de tmap_arrange() : la fonction ne permet pas de fixer un vecteur de largeur différent pour les cartes. A utiliser donc sur des cas qui peuvent convenir à cette contrainte. bbox_africa &lt;- World %&gt;% filter(continent==&quot;Africa&quot;) %&gt;% st_bbox() tmap_sdg_indicators &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;, style = &quot;jenks&quot;,palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;))+ tm_layout() tmap_sdg_indicators_africa &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape(bbox = bbox_africa)+ tm_polygons(&quot;sh_sta_mmr&quot;, style = &quot;jenks&quot;, palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;))+ tm_layout(legend.show = FALSE) tmap_arrange(tmap_sdg_indicators, tmap_sdg_indicators_africa, nrow = 1) 15.9 tmap pour le web tmap permet simplement de convertir une carte image en carte interactive. Pour cela il faut changer le mode d’affichage de la carte avec tmap_mode() tmap_mode(&quot;view&quot;) sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape()+ tm_polygons(&quot;sh_sta_mmr&quot;)+ tm_borders(&quot;white&quot;, lwd = .5) 15.10 Export d’une carte La fonction tmap_save() permet d’exporter une carte tmap. Suivant le tmap_mode() activé, l’export peut se faire en fichier image ou en fichier html. carte &lt;- sdg_indicators_sf %&gt;% filter(timeperiod == &quot;2015&quot;) %&gt;% tm_shape() + tm_polygons() + tm_bubbles( size = &quot;sh_sta_mmr&quot;, col = &quot;sh_sta_mmr&quot;, palette = viridis(5, alpha = 1, begin = 0.3, end = 1, direction = 1, option = &quot;D&quot;), title.col = &quot;&quot;, title.size = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances)&quot; ) + tm_layout( main.title = &quot;Taux de mortalité de la mère \\n(pour 100 000 naissances) dans le monde&quot;, main.title.size = 1.2, outer.margins = c(0, 0, 0, 0), legend.position = c(&quot;left&quot;, &quot;bottom&quot;), legend.outside = FALSE, main.title.position = &quot;center&quot;, inner.margins = c(0, 0, 0, 0) ) tmap_mode(&quot;plot&quot;) tmap_save(carte, filename = &quot;Taux de mortalité de la mère dans le monde.png&quot;) tmap_mode(&quot;view&quot;) tmap_save(carte, filename = &quot;Taux de mortalité de la mère dans le monde.html&quot;) "],["exercices-corrigés.html", "Chapitre 16 Exercices corrigés 16.1 Exercice 1 - manipuler des objets sf 16.2 Exercice 2 : exploitation des données DVF en API 16.3 Exercice 3 ggplot chap 10 : Visualisation des données DVF en API 16.4 Exercice 4 : Assemblage de cartes sur dvf 16.5 Exercice 5 : cartes pour le web 16.6 Exercice 6 : exercices bonus (ODD)", " Chapitre 16 Exercices corrigés 16.1 Exercice 1 - manipuler des objets sf Créer un objet contenant les points de p qui intersectent le polygone a, à partir du code suivant : library(sf) library(tidyverse) # polygone (a - orange) a_poly &lt;- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1)))) a &lt;- st_sfc(a_poly) # lignes (l - bleues) l1 &lt;- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1)))) l2 &lt;- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0)))) l &lt;- st_sfc(l1, l2) # multi-points (p - noirs) p_matrix &lt;- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2) p_multi &lt;- st_multipoint(x = p_matrix) p &lt;- st_cast(st_sfc(p_multi), &quot;POINT&quot;) library(sf) library(tidyverse) # polygone (a - orange) a_poly &lt;- st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1)))) a &lt;- st_sfc(a_poly) # lignes (l - bleues) l1 &lt;- st_multilinestring(list(rbind(c(0.5, -1), c(-0.5, 1)))) l2 &lt;- st_multilinestring(list(rbind(c(.9, -.9), c(.5, 0)))) l &lt;- st_sfc(l1, l2) # multi-points (p - noirs) p_matrix &lt;- matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2) p_multi &lt;- st_multipoint(x = p_matrix) p &lt;- st_cast(st_sfc(p_multi), &quot;POINT&quot;) Résultat attendu : # solution st_filter res &lt;- st_sf(p) %&gt;% st_filter(a) # solution tidyverse res &lt;- st_sf(p) %&gt;% filter(st_intersects(., a, sparse = FALSE)) # solution crochets res &lt;- st_sf(p)[a, , op = st_intersects] res # A tibble: 2 × 1 p &lt;POINT&gt; 1 (0.5 0) 2 (1 1) 16.2 Exercice 2 : exploitation des données DVF en API Le but de cet exercice va être d’exploiter les données DVF sur les transactions immobilières dans l’ancien et la carte des quartiers de Nantes pour obtenir des indicateurs des transactions par quartier. On va utiliser pour DVF l’API mise en place par Christian Quest : http://api.cquest.org/dvf. ## Activation des packages library(httr) library(jsonlite) library(sf) library(tidyverse) get_dvf &lt;- GET(&quot;http://api.cquest.org/dvf?code_commune=44109&quot;) dvf_content &lt;- content(get_dvf, &quot;text&quot;, encoding = &quot;UTF-8&quot;) dvf_json &lt;- fromJSON(dvf_content)$resultats %&gt;% # On ne garde que les données avec une géolocalisation valide, un prix et une surface renseignés. filter(!is.na(lon), !is.na(lat), !is.na(valeur_fonciere), !is.na(surface_relle_bati)) dvf &lt;- st_as_sf(dvf_json, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326) ## Activation des packages library(tidyverse) library(httr) library(jsonlite) library(sf) get_dvf &lt;- GET(&quot;http://api.cquest.org/dvf?code_commune=44109&quot;) dvf_content &lt;- content(get_dvf, &quot;text&quot;, encoding = &quot;UTF-8&quot;) dvf_json &lt;- fromJSON(dvf_content)$resultats %&gt;% # On ne garde que les données avec une géolocalisation valide, un prix et une surface renseignés. filter(!is.na(lon), !is.na(lat), !is.na(valeur_fonciere), !is.na(surface_relle_bati)) dvf &lt;- st_as_sf(dvf_json, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326) Contour des quartiers de Nantes, ils proviennent de Nantes Métropole Open Data :https://data.nantesmetropole.fr quartier_nantes &lt;- st_read(&quot;https://data.nantesmetropole.fr/explore/dataset/244400404_quartiers-communes-nantes-metropole/download/?format=geojson&amp;disjunctive.libcom=true&amp;refine.libcom=Nantes&amp;timezone=Europe/Berlin&amp;lang=fr&quot;) quartier_nantes &lt;- st_set_crs(quartier_nantes, 4326) quartier_nantes &lt;- st_read(&quot;https://data.nantesmetropole.fr/explore/dataset/244400404_quartiers-communes-nantes-metropole/download/?format=geojson&amp;disjunctive.libcom=true&amp;refine.libcom=Nantes&amp;timezone=Europe/Berlin&amp;lang=fr&quot;) quartier_nantes &lt;- st_set_crs(quartier_nantes, 4326) On veut produire les infos suivantes par quartier et année : Volume de ventes (nb) Pourcentage de maisons dans les ventes Prix moyen au m2 par type de bien # Jointure spatiale pour récupérer les ventes par quartiers ---- dvf_avec_quartier &lt;- st_join(dvf, quartier_nantes %&gt;% select(nom)) %&gt;% rename(quartier = nom) # Calcul indicateurs---- library(lubridate) dvf_filtre &lt;- dvf_avec_quartier %&gt;% st_drop_geometry() %&gt;% filter( nature_mutation == &quot;Vente&quot;, type_local %in% c(&quot;Appartement&quot;, &quot;Maison&quot;) ) %&gt;% mutate( date_mutation = ymd(date_mutation), annee_mutation = year(date_mutation), nb_ventes = 1 ) # Calculs volumes, surfaces, prix totaux par quartier, par type de bien et par année stat1 &lt;- dvf_filtre %&gt;% group_by(quartier, type_local, annee_mutation) %&gt;% summarise(across(c(nb_ventes, valeur_fonciere, surface_relle_bati), sum, na.rm = TRUE), .groups = &quot;drop&quot;) # Calculs volumes, surfaces, prix totaux par quartier et par année, ensemble maisons + appartements stat2 &lt;- dvf_filtre %&gt;% group_by(quartier, annee_mutation) %&gt;% summarise(across(c(nb_ventes, valeur_fonciere, surface_relle_bati), sum, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% mutate(type_local = &quot;Ensemble&quot;) stat &lt;- bind_rows(stat1, stat2) Résultat attendu : # Calcul volume des ventes indicateurs1 &lt;- stat %&gt;% filter(type_local == &quot;Ensemble&quot;) %&gt;% select(quartier, annee_mutation, nb_ventes) # Calcul pourcentage de maison dans les ventes indicateurs2 &lt;- stat %&gt;% select(quartier, annee_mutation, type_local, nb_ventes) %&gt;% pivot_wider(names_from = type_local, values_from = nb_ventes, values_fill = 0) %&gt;% mutate(pourcentage_maison = 100 * Maison / Ensemble) %&gt;% select(quartier, annee_mutation, pourcentage_maison) # Calcul des prix au m2 indicateurs3 &lt;- stat %&gt;% select(quartier, annee_mutation, type_local, valeur_fonciere, surface_relle_bati) %&gt;% mutate(prix_m2 = valeur_fonciere / surface_relle_bati) %&gt;% select(quartier, annee_mutation, type_local, prix_m2) %&gt;% pivot_wider(names_from = type_local, values_from = prix_m2) %&gt;% rename_with(.cols = c(Appartement, Maison, Ensemble), .fn = ~paste0(&quot;prix_m2_&quot;, tolower(.x))) # Assemblage des tables d&#39;indicateurs indicateurs &lt;- reduce(list(indicateurs1, indicateurs2, indicateurs3), left_join) # Réintroduction géométries indicateurs &lt;- quartier_nantes %&gt;% select(quartier = nom) %&gt;% left_join(indicateurs) indicateurs %&gt;% glimpse() Rows: 66 Columns: 8 $ quartier &lt;chr&gt; &quot;Ile de Nantes&quot;, &quot;Ile de Nantes&quot;, &quot;Ile de Nantes&quot;,… $ annee_mutation &lt;dbl&gt; 2014, 2015, 2016, 2017, 2018, 2019, 2014, 2015, 20… $ nb_ventes &lt;dbl&gt; 255, 346, 405, 464, 475, 221, 212, 203, 196, 224, … $ pourcentage_maison &lt;dbl&gt; 1.960784, 2.312139, 2.962963, 1.293103, 1.263158, … $ prix_m2_appartement &lt;dbl&gt; 4227.436, 2720.641, 3583.049, 3496.280, 3574.651, … $ prix_m2_maison &lt;dbl&gt; 3208.333, 2961.019, 19695.106, 3519.273, 4144.621,… $ prix_m2_ensemble &lt;dbl&gt; 4187.948, 2728.811, 4208.121, 3496.700, 3587.453, … $ geometry &lt;POLYGON [°]&gt; POLYGON ((-1.518491 47.2105..., POLYGON ((… 16.3 Exercice 3 ggplot chap 10 : Visualisation des données DVF en API Avec les résultats de l’exercice 2, produire les cartes du nombre de ventes et du prix au m2 des maisons en 2019 par quartier de Nantes. Résultats attendus : library(tidyverse) library(gouvdown) ggplot() + geom_sf( data = indicateurs %&gt;% filter(annee_mutation == 2019), aes(fill = nb_ventes) ) + theme_gouv_map() + scale_fill_gouv_continuous() ggplot() + geom_sf( data = indicateurs %&gt;% filter(annee_mutation == 2019), aes(fill = prix_m2_maison) ) + theme_gouv_map() + scale_fill_gouv_continuous() 16.4 Exercice 4 : Assemblage de cartes sur dvf A partir des données dvf 2014 et 2017 de la région Pays de la Loire contenues dans le package {variousdata} et les fonds de carte de {COGiter}, produire : une carte régionale à l’EPCI comprenant : un dégrade de couleur sur l’évolution des prix au m2 des maisons entre 2014 et 2017, un rond sur le volume des prix au m2 des maisons, un zoom sur les communes des principaux EPCI, c’est à dire une carte à la commune par EPCI de type Métropole (ME) ou Communauté urbaine (CU). Puis, assembler ces différentes cartes sur un même graphique. ## Activation des packages library(tidyverse) library(sf) library(lubridate) library(variousdata) library(cowplot) library(stringr) library(COGiter) library(gouvdown) ## Préparation des données ### Fonds de carte epci_geo_r52 &lt;- COGiter::epci_geo %&gt;% left_join(COGiter::epci, by = &quot;EPCI&quot;) %&gt;% filter(grepl(&quot;52&quot;, REGIONS_DE_L_EPCI)) epci_ppaux_r52 &lt;- filter(epci_geo_r52, NATURE_EPCI %in% c(&#39;ME&#39;, &quot;CU&quot;)) %&gt;% pull(EPCI) # communes des EPCI principaux com_epci_ppaux_r52 &lt;- COGiter::communes_geo %&gt;% left_join(COGiter::communes, by = &quot;DEPCOM&quot;) %&gt;% filter(EPCI %in% epci_ppaux_r52) ### dvf data(&quot;dvf_r52&quot;) dvf_r52 &lt;- dvf_r52 %&gt;% select(-c(NOM_DEPCOM:NOM_REG)) %&gt;% passer_au_cog_a_jour(code_commune = DEPCOM, garder_info_supra = TRUE, aggrege = FALSE) # On ne conserve que les données valides de ventes de maisons, et on les tronque, en filtrant les données à 98% pour lisser les moyennes dvf_r52_maisons &lt;- dvf_r52 %&gt;% filter(nature_mutation == &quot;Vente&quot;, type_local == &quot;Maison&quot;) %&gt;% filter(!is.na(valeur_fonciere), !is.na(surface_reelle_bati)) %&gt;% mutate(prix_m2 = valeur_fonciere / surface_reelle_bati) %&gt;% arrange(prix_m2) %&gt;% filter(between(row_number(), n() * .01, n() * .99)) %&gt;% select(-prix_m2) Il faut comme toujours procéder par étape. Etape 1 : Calcul de l’évolution des prix et du nombre de ventes A l’EPCI prix_m2_maisons_epci &lt;- dvf_r52_maisons %&gt;% select(EPCI, NOM_EPCI, date_mutation, valeur_fonciere, surface_reelle_bati) %&gt;% mutate( n = 1, annee = year(date_mutation) ) %&gt;% select(-date_mutation) %&gt;% group_by(EPCI, NOM_EPCI, annee) %&gt;% summarise(across(everything(), sum), .groups = &quot;drop&quot;) %&gt;% group_by(EPCI, NOM_EPCI) %&gt;% mutate( prix_m2 = valeur_fonciere / surface_reelle_bati, evo_prix_m2 = 100 * prix_m2 / lag(prix_m2) - 100 ) %&gt;% filter(annee == 2017) %&gt;% ungroup() A la commune prix_m2_maisons_com &lt;- dvf_r52_maisons %&gt;% select(EPCI, DEPCOM, date_mutation, valeur_fonciere, surface_reelle_bati) %&gt;% mutate( n = 1, annee = year(date_mutation) ) %&gt;% select(-date_mutation) %&gt;% group_by(EPCI, DEPCOM, annee) %&gt;% summarise(across(everything(), sum), .groups = &quot;drop&quot;) %&gt;% group_by(EPCI, DEPCOM) %&gt;% mutate( prix_m2 = valeur_fonciere / surface_reelle_bati, evo_prix_m2 = 100 * prix_m2 / lag(prix_m2) - 100 ) %&gt;% filter(annee == 2017) %&gt;% ungroup() Intégration des données calculées aux fonds de carte prix_m2_maisons_epci_sf &lt;- epci_geo_r52 %&gt;% left_join(prix_m2_maisons_epci, by = c(&quot;EPCI&quot;, &quot;NOM_EPCI&quot;)) %&gt;% mutate(n = coalesce(n, 0)) prix_m2_maisons_com_sf &lt;- com_epci_ppaux_r52 %&gt;% left_join(prix_m2_maisons_com, by = c(&quot;DEPCOM&quot;, &quot;EPCI&quot;)) %&gt;% mutate(n = coalesce(n, 0)) %&gt;% filter() Etape 2 : Datavisualisation Carte à l’EPCI de la région p &lt;- ggplot(prix_m2_maisons_epci_sf) + geom_sf(aes(fill = evo_prix_m2)) + scale_fill_gouv_continuous(palette = &quot;pal_gouv_div1&quot;) + stat_sf_coordinates(aes(size = n), alpha = .5) + theme_gouv_map(plot_title_size = 16, subtitle_size = 12, plot_margin = margin(0, 0, 0, 0), plot_title_margin = 1, caption_margin = 1, subtitle_margin = 0) + guides(size = &quot;none&quot;) + labs( fill = &quot;En %&quot;, title = &quot;Evolution du prix des maisons neuves en euros par m2&quot;, subtitle = &quot;Entre 2014 et 2017&quot;, caption = &quot;source : DVF&quot; ) p Zooms à la commune # Création des cartes zoom EPCI avec une fonction creer_zoom &lt;- function(code_epci = &quot;244400404&quot;) { nom_epci &lt;- filter(epci_geo_r52, EPCI == code_epci) %&gt;% pull(NOM_EPCI) %&gt;% str_wrap(20) prix_m2_maisons_com_sf %&gt;% filter(EPCI == code_epci) %&gt;% ggplot() + geom_sf(aes(fill = evo_prix_m2)) + scale_fill_gouv_continuous(palette = &quot;pal_gouv_div1&quot;) + stat_sf_coordinates(aes(size = n), alpha = .5) + theme_gouv_map(plot_title_size = 11, plot_margin = margin(0, 0, 0, 0), plot_title_margin = 1, caption_margin = 1, subtitle_margin = 0) + guides(size = &quot;none&quot;, fill = &quot;none&quot;) + labs(title = nom_epci) } # Réalisation des zooms zooms &lt;- map(.x = epci_ppaux_r52, .f = creer_zoom) zooms[[1]] Assemblage plot_grid(p, plot_grid(zooms[[1]], zooms[[2]], zooms[[4]], nrow = 2, ncol = 3), nrow = 2) 16.5 Exercice 5 : cartes pour le web Adapter la carte régionale à l’EPCI de l’exercice 4, pour le web : au survol d’un EPCI, afficher son nom, le prix au m2 et son évolution 2014-2017, au survol du rond d’un EPCI, afficher son nom, le nb de ventes 2017. library(ggiraph) library(mapfactory) p_web &lt;- prix_m2_maisons_epci_sf %&gt;% mutate( sign_evol = if_else(evo_prix_m2 &gt;=0, &quot;+&quot;, &quot;&quot;), tooltip_fill = paste0(NOM_EPCI, &quot; :\\n&quot;, format_fr(x = prix_m2, dec = 0),&quot; €/m2 en 2017\\n&quot;, sign_evol, format_fr(x = evo_prix_m2, pourcent = TRUE), &quot; depuis 2014&quot;), tooltip_size = paste0(NOM_EPCI, &quot; :\\n&quot;, n,&quot; ventes en 2017&quot;) ) %&gt;% ggplot() + geom_sf_interactive(aes(fill = evo_prix_m2, tooltip = tooltip_fill)) + scale_fill_gouv_continuous(palette = &quot;pal_gouv_div1&quot;) + geom_point_interactive(stat = &quot;sf_coordinates&quot;, aes(geometry = geometry, size = n, tooltip = tooltip_size), alpha = .5) + theme_gouv_map(plot_title_size = 16, subtitle_size = 12, plot_margin = margin(3, 3, 3, 3), plot_title_margin = 3, caption_margin = 2, subtitle_margin = 2) + guides(size = &quot;none&quot;) + labs( fill = &quot;En %&quot;, title = &quot;Evolution du prix au m2 des maisons neuves&quot;, subtitle = &quot;Entre 2014 et 2017&quot;, caption = &quot;source : DVF&quot; ) ggiraph(ggobj = p_web) 16.6 Exercice 6 : exercices bonus (ODD) Faire une carte à de ronds proportionnels à partir des données sur les ODD En taille des ronds : le taux de mortalité des mères à naissance En couleur : l’évolution de la mortalité des mères à la naissance entre 2000 et 2015 Rajouter deux zooms sur les continents Africain et Sud Américain Source : les données : sdg_indicators du package variousdata le fond de carte : la table World du package tmap 16.6.1 Chargement des données et datapréparation library(tidyverse) library(tmap) library(variousdata) library(sf) library(cowplot) data(&quot;World&quot;) data(&quot;sdg_indicators&quot;) World_centroid &lt;- st_centroid(World, of_largest_polygon = T) sdg_indicators_sf_centroid &lt;- World_centroid %&gt;% left_join(sdg_indicators) sdf_indicators_evo_2000_2015_sf &lt;- sdg_indicators_sf_centroid %&gt;% filter(timeperiod %in% c(&quot;2000&quot;, &quot;2015&quot;), !is.na(sh_sta_mmr)) %&gt;% group_by(iso_a3) %&gt;% mutate(evo_sh_sta_mmr = 100 * (sh_sta_mmr / lag(sh_sta_mmr) - 1)) %&gt;% select(timeperiod, iso_a3, geoareaname, sh_sta_mmr, evo_sh_sta_mmr) %&gt;% ungroup() %&gt;% filter(timeperiod == &quot;2015&quot;) sdf_indicators_evo_2000_2015_sf %&gt;% glimpse() Rows: 167 Columns: 6 $ timeperiod &lt;fct&gt; 2015, 2015, 2015, 2015, 2015, 2015, 2015, 2015, 2015, 2… $ iso_a3 &lt;fct&gt; AFG, AGO, ALB, ARE, ARG, ARM, AUS, AUT, AZE, BDI, BEL, … $ geoareaname &lt;fct&gt; &quot;Afghanistan&quot;, &quot;Angola&quot;, &quot;Albania&quot;, &quot;United Arab Emirat… $ sh_sta_mmr &lt;dbl&gt; 396, 477, 29, 6, 52, 25, 6, 4, 25, 712, 7, 405, 371, 17… $ evo_sh_sta_mmr &lt;dbl&gt; -64.00000, -48.37662, -32.55814, -25.00000, -13.33333, … $ geometry &lt;POINT [°]&gt; POINT (66.00365 33.84035), POINT (17.49892 -12.27… 16.6.2 Datavisualisation 16.6.3 Carte monde Résultat intermédiaire : map1 &lt;- ggplot(data = sdf_indicators_evo_2000_2015_sf) + geom_sf(data = World, fill = &quot;white&quot;) + geom_sf(aes(color = evo_sh_sta_mmr, size = sh_sta_mmr)) + theme_minimal() + theme( panel.background = element_rect(fill = &quot;light blue&quot;), legend.position = &quot;right&quot; ) + guides(size = F) + scale_color_gradient2() + labs( title = &quot;Evolution de la mortalité de la mère à la naissance&quot;, subtitle = &quot;Entre 2000 et 2015&quot;, color = &quot;Evolution\\nen %&quot; ) map1 16.6.4 Zoom sur les deux continents On va utiliser la bbox pour définir les bornes de notre carte zoomée. Résultat intermédiaire : bbox_south_america &lt;- World %&gt;% filter(continent == &quot;South America&quot;) %&gt;% st_bbox() map2 &lt;- ggplot(data = sdf_indicators_evo_2000_2015_sf) + geom_sf(data = World, fill = &quot;white&quot;) + geom_sf(aes(color = evo_sh_sta_mmr, size = sh_sta_mmr)) + coord_sf( xlim = c(bbox_south_america[1], bbox_south_america[3]), ylim = c(bbox_south_america[2], bbox_south_america[4]) ) + theme_void() + theme( panel.background = element_rect(fill = &quot;light blue&quot;), legend.position = &quot;none&quot; ) + scale_color_gradient2() map2 Résultat intermédiaire : bbox_africa &lt;- World %&gt;% filter(continent == &quot;Africa&quot;) %&gt;% st_bbox() map3 &lt;- ggplot(data = sdf_indicators_evo_2000_2015_sf) + geom_sf(data = World, fill = &quot;white&quot;) + geom_sf(aes(color = evo_sh_sta_mmr, size = sh_sta_mmr)) + coord_sf( xlim = c(bbox_africa[1], bbox_africa[3]), ylim = c(bbox_africa[2], bbox_africa[4]) ) + theme_void() + theme( panel.background = element_rect(fill = &quot;light blue&quot;), legend.position = &quot;none&quot; ) + scale_color_gradient2() map3 16.6.5 Assemblage Résultat attendu : ggdraw() + draw_plot(map1, x = 0, y = .45, width = 1, height = .55) + draw_plot(map2, x = 0.2, y = 0, width = .25, height = .45) + draw_plot(map3, x = 0.45, y = 0, width = .25, height = .45) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
